> 学习面向对象的三条主线
>
> 1. Java类及类的成员：属性、方法、构造器；代码块、内部类
> 2. 面向对象的三大特征：封装、继承、多态
> 3. 其他关键字



# 前言

> 面向过程（POP）与面向对象（OOP）
>
> - 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做
> - 面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

> 面向对象的两个要素
>
> - 类：对一类事物的描述，是抽象的、概念的定义
> - 对象：是实际存在的该类事物的每个个体，因此也称作实例（instance）



> 面向对象的重点就是类的设计
>
> 类的设计，就是设计类的成员



# 一、类的结构



- 属性，也称作 成员变量 、field 、域、字段
- 方法，也称作 成员方法、函数、method

- 构造器
- 代码块
- 内部类

> 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static）

```java
public class PersonTest{
    public static void main(String[] args){
        //创建Person类的对象
        Person p1 = new Person();
        
        //调用属性
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法
        p1.sleep();
        p1.talk("English");
        
        //将p1变量保存的对象地址值赋给p3
        Person p3 = p1;
        System.out.println(p3.name);//Tom
        
    }
}


class Person{
    //属性
    String name;
    int age = 1;
    boolean isMale;
    
    //方法
    public void eat(){
        String food = "烙饼";//局部变量
        System.out.println("People can eat"+food);
    }
    public void sleep(){
        System.out.println("People can sleep");
    }
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }
}
```





## 1、属性的使用

> 属性（成员变量）  VS  局部变量
>
> 相同点：
>
> ​			声明方式一样；先声明后使用；
>
> 不同点：
>
> 1.声明位置的不同
>
> ​		属性：直接定义在类的一对{ }内
>
> ​		局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
>
> 2.关于权限修饰符不同
>
> ​		属性：可以在声明属性时，指明其权限，使用权限修饰符
>
> ​					常用的权限修饰符：private、public、缺省、protected
>
> ​		局部变量：不可以使用权限修饰符
>
> 3.默认初始化值
>
> ​		属性：类的属性根据其情况，都有默认初始化值
>
> - 整型（`byte`,`int`,`short`,`long`）：0
>
> - 浮点型（`float`,`double`）：0.0
>
> - 字符型（char）：0（或`\u0000`）
>
> - 引用类型（类、数组、接口）：null
>
> 	局部变量：没有默认初始值
>
> - 在调用局部变量前，一定要赋值
>
> - 特别的，形参在调用方法时赋值
>
> 4.在内存中加载的位置
>
> ​	属性：在堆空间中加载（非static）
>
> ​	局部变量：在栈空间中加载



```java
class User{
    //属性
    String name;
    public int age = 1;
    
    public void eat(){
    	String food = "烙饼";//局部变量
    	System.out.println("People can eat"+food);
    }
    
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }  
}
```





## 2、方法的使用

> 1. 方法的声明 ：
>
> 	权限修饰符  返回值类型  方法名（数据类型1 形参1，数据类型2 形参2）{
>
> 	​								方法体
>
> 	}
>
> 2. 常用的权限修饰符：private、public、缺省、protected
>
> 3. 没有返回值用void表示
>
> 4. return关键字，可以用来返回值&结束方法
>
> 5. <font color="red">方法中，不可以定义方法</font>



```java
public class CustomerTest{

    public static void main(String[] args) {
        BuyFood child = new BuyFood();
        child.weight=2.1;
        String food = "bread";
        int price = 1;
       
        System.out.println(child.foodPrice(food,price));//2
    }

}
class BuyFood{
    double weight;
    public int foodPrice(String food,int price){
        
        System.out.println("food "+weight+"kg is enough ");
        System.out.println(food+" is worth five dollars");

        return ++price;
    }
}
```



## 3、JVM内存结构与对象解析

![image-20201108154358774](C:%5CUsers%5C%E4%BB%BB%E5%8D%9A%5CDocuments%5CWPS%20Cloud%20Files%5C265697358%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5Cimage-20201108154358774.png)

- 虚拟机栈，即平时所说的栈结构。<font color="red">我们平时将局部变量存储在栈结构</font>
- 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。对象的属性（非static）也在堆空间中
- 方法区：类的加载信息、常量池、静态域



# 二、万事万物皆对象

> 1.理解万事万物皆对象
>
> - 在Java语言中，我们都将功能、结构封装到类中，通过类的实例化，来调用具体的功能结构
> 	- Scanner、String等
> 	- 文件：File

## 1、对象数组

```java
public class InstanceTest{
    public static void main(String[] args){
        
        //数组元素是Student，如String[] str = new String
        //[]才表示数组,该情况下数组初试化值为null，即[null,null,null,null,null]
        Student[] stus = new Student[5];
        stus[0] = new Student();//数组元素是Student，只能存储Student类型
        
        System.out.println("stus[0].state:"+stus[0].state);
    }
}
class Student{
    int number;
    int state = 1;
    int score;
}
```



## 2、匿名对象

```java
public class InstanceTest{
    public static void main(String[] args){
        //匿名对象,没有给对象命名，直接调用方法
        new Phone().sendEmail();

        new Phone().price=100;
        new Phone().showPrice();//每次对象都是新的
		
        //匿名对象的使用
        SendMessage sendmes = new SendMessage();
        sendmes.show(new Phone());
    }
}

class SendMessage{
    //自定义的类可以用作形参
    public void show(Phone phone){//也可以说把new Phone()命名为形参phone。形参也是局部变量。
        phone.sendEmail();
        phone.showPrice();
    }
}

class Phone{
    double price;
    public void sendEmail(){
        System.out.println("发送邮件");
    }
    public void showPrice(){
        System.out.println("手机价格："+price);
    }
}


```



## 3、方法的重载

> 方法的重载（overload）
>
> 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的<font color="red">参数个数</font>或者<font color="red">参数类型</font>不同即可



```java
class OverLoad{
    //如下的两个方法构成了方法重载
    //根据参数类型来选择调用哪个函数
	public void reverse(int number){
        System.out.println("number:"+number);
    }    
    public void reverse(String number){
        System.out.println("number:"+number);
    }
}
```

- 方法重载的自动类型提升
	- 故调用方法时，不但需要看类的方法名，还要看方法的参数列表

```java
	public class OverLoadTest{
	    public static void main(String[] args){
	        OverLoadTest ovl = new OverLoadTest();
	        ovl.getSum(1,2);//变成了double型
	    }
	    //不注释的话，优先会选int。注释后会去匹配，进行自动类型提升
	//    public getSum(int i , int j){
	//        System.out.println("1");
	//    }
	    public getSum(double i , double j){
	        System.out.println("2");
	    }
	    public getSum(String i , int j){
	        System,out.println("3";)
	    }
	}
```





## 4、可变个数形参

>定义：允许直接定义能和==多个==实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参
>
>- 调用可变数目形参的方法时，传入的参数可以是：0个、1个、2个...
>
>- 如果存在只有一个参数的方法，那么会优先识别那个方法，而不是可变数目形参的方法



```java
public class MethodArgsTest{
    //1.可变数目的形参
    public void show(String ... strs){
    	//使用方式和数组的使用方式一样
    	//区别是，与传入数组类型相比，本方法参数类型不用定义为数组，如show(new String[]{1,2,3})。可以直接为show(1,2,3)
        //本方法的传入参数也可以为数组类型,如show(new String[]{1,2,3})
        System.out.println("4");
    }
    
    //2.与1的构成重载
    public void show(String strs){
        System.out.println("5");
    }
    
    //3.报错，与1的不构成重载，不能共存
    //因为JDK1.5以前是用数组传入多个值
    public void show(String[] strs){
        System.out.println("6");
    }
    
    //4.可变数目参数必须放在最后
    public void show(int i,String ... strs){
        System.out.println("6");
    }
}
```



## 5、方法参数的值传递机制

> - 形参：方法声明时的参数
>
> - 实参：方法调用时实际传给形参的参数值
>
> 	```java
> 	int a = 0;
> 	show(a);//a还是实参
> 	public void show(a){//a是形参
> 	    return;
> 	}
> 	//相当于实参a赋值给形参a
> 	```
>
> 	

### 值传递机制：

- Java里方法的参数传递方式只有一种：<font color="red">值传递</font>。

- 形参是基本数据类型：将实参（基本数据类型变量）的`数据值`传给形参
- 形参是引用数据类型：将实参（引用数据类型变量）的`地址值`传给形参



### 变量的赋值：

- 如果A变量是基本数据类型，`B=A`，此时赋值的是A变量保存的数据值
- 如果A变量是引用数据类型，`B=A`，此时赋值的是A变量保存的数据的地址值

```java
//附加题
public class Test{
    public static void main(String[] args){
        int a=10;
        int b=10;
        //需要在method方法调用后，仅打印出a=100，b=200，写出method的代码
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }
    //方法一
    public static void method(int a,int b){
        a=a*10;
        b=b*20;
        System.out.println("a="+a);
        System.out.println("b="+b);
        System.exit(0);//退出程序。终止JVM的执行
    }
    //方法二,重写打印流
    public static void method(int a,int b){
        PrintStream ps = new PrintStream(System.out){
            @Override
            public void println(String x){
                if ("a=10".equals(x)){
                    x = "a=100";
                } 
                else if ("b=10".equals(x)){
                    x = "b=200";
                }
                super.println(x);
            }
        };
        System.setOut(ps);
    }
}
```



# 面向对象特征：封装与隐藏

> 为什么要封装？
>
> - 我要用洗衣机，只要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗
>
> - 我们的程序追求“高内聚，低耦合”
> 	- 高内聚：类的内部操作细节自己完成，不允许外部干涉
> 	- 低耦合：仅对外暴露少量的方法用于是用
> - 隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性
> - 把该隐藏的隐藏，该暴露的暴露，就是封装性的设计思想