> 学习面向对象的三条主线
>
> 1. Java类及类的成员：属性、方法、构造器；代码块、内部类
> 2. 面向对象的三大特征：封装、继承、多态
> 3. 其他关键字



# 前言

> 面向过程（POP）与面向对象（OOP）
>
> - 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做
> - 面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

> 面向对象的两个要素
>
> - 类：对一类事物的描述，是抽象的、概念的定义
> - 对象：是实际存在的该类事物的每个个体，因此也称作实例（instance）



> 面向对象的重点就是类的设计
>
> 类的设计，就是设计类的成员



# 一、类的结构



- 属性，也称作 成员变量 、field 、域、字段
- 方法，也称作 成员方法、函数、method

- 构造器
- 代码块
- 内部类

> 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static）

```java
public class PersonTest{
    public static void main(String[] args){
        //创建Person类的对象
        Person p1 = new Person();
        
        //调用属性
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法
        p1.sleep();
        p1.talk("English");
        
        //将p1变量保存的对象地址值赋给p3
        Person p3 = p1;
        System.out.println(p3.name);//Tom
        
    }
}


class Person{
    //属性
    String name;
    int age = 1;
    boolean isMale;
    
    //方法
    public void eat(){
        String food = "烙饼";//局部变量
        System.out.println("People can eat"+food);
    }
    public void sleep(){
        System.out.println("People can sleep");
    }
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }
}
```





## 1、属性的使用

> 属性（成员变量）  VS  局部变量
>
> 相同点：
>
> ​			声明方式一样；先声明后使用；
>
> 不同点：
>
> 1.声明位置的不同
>
> ​		属性：直接定义在类的一对{ }内
>
> ​		局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
>
> 2.关于权限修饰符不同
>
> ​		属性：可以在声明属性时，指明其权限，使用权限修饰符
>
> ​					常用的权限修饰符：private、public、缺省、protected
>
> ​		局部变量：不可以使用权限修饰符
>
> 3.默认初始化值
>
> ​		属性：类的属性根据其情况，都有默认初始化值
>
> - 整型（`byte`,`int`,`short`,`long`）：0
>
> - 浮点型（`float`,`double`）：0.0
>
> - 字符型（char）：0（或`\u0000`）
>
> - 引用类型（类、数组、接口）：null
>
> 	局部变量：没有默认初始值
>
> - 在调用局部变量前，一定要赋值
>
> - 特别的，形参在调用方法时赋值
>
> 4.在内存中加载的位置
>
> ​	属性：在堆空间中加载（非static）
>
> ​	局部变量：在栈空间中加载



- 类的属性可以为自定义类，`private Account account;`
	- 类似`String name;`
	- 两个类形成关联关系
- 类的属性可以为对象数组。`private Customer[] customers;`
	- 数组里面的元素是Customer类型的

```java
class User{
    //属性
    String name;
    public int age = 1;
    
    public void eat(){
    	String food = "烙饼";//局部变量
    	System.out.println("People can eat"+food);
    }
    
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }  
}
```





## 2、方法的使用

> 1. 方法的声明 ：
>
> 	权限修饰符  返回值类型  方法名（数据类型1 形参1，数据类型2 形参2）{
>
> 	​								方法体
>
> 	}
>
> 2. 常用的权限修饰符：private、public、缺省、protected
>
> 3. 没有返回值用void表示
>
> 4. return关键字，可以用来返回值&结束方法
>
> 5. <font color="red">方法中，不可以定义方法</font>



```java
public class CustomerTest{

    public static void main(String[] args) {
        BuyFood child = new BuyFood();
        child.weight=2.1;
        String food = "bread";
        int price = 1;
       
        System.out.println(child.foodPrice(food,price));//2
    }

}
class BuyFood{
    double weight;
    public int foodPrice(String food,int price){
        
        System.out.println("food "+weight+"kg is enough ");
        System.out.println(food+" is worth five dollars");

        return ++price;
    }
}
```



## 3、构造器

> 构造器的作用：
>
> >  类似`def __init__(self)`
>
> - 创造对象：
>
>   - 创建类的对象：new+构造器
>   - `Person P = new Person()`，`Person()`称作构造器
>
> - 初始化对象的属性
>
>   
>
>   说明：
>
>   1、如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
>
>   2、一旦显式的定义类的构造器，系统不再提供一个默认空参的构造器
>
>   3、定义构造器的格式：            权限修饰符  	类名(形参列表){ }
>
>   4、一个类中定义多个构造器，彼此构成重载
>
>   5、一个类中至少会有一个构造器(如果不定义，系统也强塞一个)
>   
>   6、没有返回值





```java
public class PersonTest{
    //创建类的对象：new + 构造器
    Person P = new Person();
}

class Person{
    //属性
    String name;
    int age;
    
    //构造器
    //名字必须和类名一样
    //有了构造器后，new Person()时，会自动执行构造器内的内容，像 def __init__(self):
    public Person(String n){
        name = n
        System.out.println("构造器1");
    }
    //构造器的重载
    public Person(int n){
        age = n
        System.out.println("构造器2");
    }
    
    //方法
    public void eat(){
        System.out.println("吃饭");
}
```









# 二、万事万物皆对象

> 1.理解万事万物皆对象
>
> - 在Java语言中，我们都将功能、结构封装到类中，通过类的实例化，来调用具体的功能结构
> 	- Scanner、String等
> 	- 文件：File

## 1、对象数组

```java
public class InstanceTest{
    public static void main(String[] args){
        
        //数组元素是Student，如String[] str = new String
        //[]才表示数组,该情况下数组初试化值为null，即[null,null,null,null,null]
        Student[] stus = new Student[5];
        stus[0] = new Student();//数组元素是Student，只能存储Student类型
        
        System.out.println("stus[0].state:"+stus[0].state);
    }
}
class Student{
    int number;
    int state = 1;
    int score;
}
```



## 2、匿名对象

```java
public class InstanceTest{
    public static void main(String[] args){
        //匿名对象,没有给对象命名，直接调用方法
        new Phone().sendEmail();

        new Phone().price=100;
        new Phone().showPrice();//每次对象都是新的
		
        //匿名对象的使用
        SendMessage sendmes = new SendMessage();
        sendmes.show(new Phone());
    }
}

class SendMessage{
    //自定义的类可以用作形参
    public void show(Phone phone){//也可以说把new Phone()命名为形参phone。形参也是局部变量。
        phone.sendEmail();
        phone.showPrice();
    }
}

class Phone{
    double price;
    public void sendEmail(){
        System.out.println("发送邮件");
    }
    public void showPrice(){
        System.out.println("手机价格："+price);
    }
}


```



## 3、方法的重载

> 方法的重载（overload）
>
> 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的<font color="red">参数个数</font>或者<font color="red">参数类型</font>不同即可



```java
class OverLoad{
    //如下的两个方法构成了方法重载
    //根据参数类型来选择调用哪个函数
	public void reverse(int number){
        System.out.println("number:"+number);
    }    
    public void reverse(String number){
        System.out.println("number:"+number);
    }
}
```

- 方法重载的自动类型提升
	- 故调用方法时，不但需要看类的方法名，还要看方法的参数列表

```java
	public class OverLoadTest{
	    public static void main(String[] args){
	        OverLoadTest ovl = new OverLoadTest();
	        ovl.getSum(1,2);//变成了double型
	    }
	    //不注释的话，优先会选int。注释后会去匹配，进行自动类型提升
	//    public getSum(int i , int j){
	//        System.out.println("1");
	//    }
	    public getSum(double i , double j){
	        System.out.println("2");
	    }
	    public getSum(String i , int j){
	        System,out.println("3";)
	    }
	}
```





## 4、可变个数形参

>定义：允许直接定义能和==多个==实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参
>
>- 调用可变数目形参的方法时，传入的参数可以是：0个、1个、2个...
>
>- 如果存在只有一个参数的方法，那么会优先识别那个方法，而不是可变数目形参的方法



```java
public class MethodArgsTest{
    //1.可变数目的形参
    public void show(String ... strs){
    	//使用方式和数组的使用方式一样
    	//区别是，与传入数组类型相比，本方法参数类型不用定义为数组，如show(new String[]{1,2,3})。可以直接为show(1,2,3)
        //本方法的传入参数也可以为数组类型,如show(new String[]{1,2,3})
        System.out.println("4");
    }
    
    //2.与1的构成重载
    public void show(String strs){
        System.out.println("5");
    }
    
    //3.报错，与1的不构成重载，不能共存
    //因为JDK1.5以前是用数组传入多个值
    public void show(String[] strs){
        System.out.println("6");
    }
    
    //4.可变数目参数必须放在最后
    public void show(int i,String ... strs){
        System.out.println("6");
    }
}
```



## 5、方法参数的值传递机制

> - 形参：方法声明时的参数
>
> - 实参：方法调用时实际传给形参的参数值
>
> 	```java
> 	int a = 0;
> 	show(a);//a还是实参
> 	public void show(a){//a是形参
> 	    return;
> 	}
> 	//相当于实参a赋值给形参a
> 	```
>
> 	

### 值传递机制：

- Java里方法的参数传递方式只有一种：<font color="red">值传递</font>。

- 形参是基本数据类型：将实参（基本数据类型变量）的`数据值`传给形参
- 形参是引用数据类型：将实参（引用数据类型变量）的`地址值`传给形参



### 变量的赋值

- 如果A变量是基本数据类型，`B=A`，此时赋值的是A变量保存的数据值
- 如果A变量是引用数据类型，`B=A`，此时赋值的是A变量保存的数据的地址值

```java
//附加题
public class Test{
    public static void main(String[] args){
        int a=10;
        int b=10;
        //需要在method方法调用后，仅打印出a=100，b=200，写出method的代码
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }
    //方法一
    public static void method(int a,int b){
        a=a*10;
        b=b*20;
        System.out.println("a="+a);
        System.out.println("b="+b);
        System.exit(0);//退出程序。终止JVM的执行
    }
    //方法二,重写打印流
    public static void method(int a,int b){
        PrintStream ps = new PrintStream(System.out){
            @Override
            public void println(String x){
                if ("a=10".equals(x)){
                    x = "a=100";
                } 
                else if ("b=10".equals(x)){
                    x = "b=200";
                }
                super.println(x);
            }
        };
        System.setOut(ps);
    }
}
```



# 面向对象特征：封装与隐藏

> 一、为什么要封装？
>
> - 我要用洗衣机，只要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗
>
> - 我们的程序追求“高内聚，低耦合”
> 	- 高内聚：类的内部操作细节自己完成，不允许外部干涉
> 	- 低耦合：仅对外暴露少量的方法用于是用
> - 隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性
> - 把该隐藏的隐藏，该暴露的暴露，就是封装性的设计思想

> 封装性的举例：
>
> 将类的属性X私有化（private），同时提供公共的（public）方法来获取和设置此属性的值



## 描述封装性

Java提供4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小



## 四种权限修饰符

Java规定的4种权限修饰符（从小到大排列）

- private、缺省(默认)、protected、public

| 修饰符     | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| ---------- | ------ | -------- | ------------ | ---------- |
| private    | Yes    |          |              |            |
| 缺省(默认) | Yes    | Yes      |              |            |
| protected  | Yes    | Yes      | Yes          |            |
| public     | Yes    | Yes      | Yes          | Yes        |

> 不同包的子类指的是，不同包下，以该类为父类的子类

- 4种权限可以用来修饰类的内部结构：属性、方法、构造器、内部类

- 只可以用`public `和 `缺省（默认）`来修饰类
  - public类，可以在任意地方被访问
  - 缺省的类，只可以被同一个包内部的类访问

- ==即便引用该包，也不能在别的包下使用，该包缺省修饰的类==

```java
public class OrderTest{
    private int number;
    
    private void methodPrivate(){
        System.out.println("private");
    }
    void methodDefault(){
        System.out.println("default");
    }
    public void methodPublic(){
        System.out.println("public");
    }
}
class OrderTestEx{
    int age;
    public int money;
}
```





# EX-1、JVM内存结构与对象解析

![](E:%5CLearning%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5Cimage-20201108154358774.png)

- 虚拟机栈，即平时所说的栈结构。<font color="red">我们平时将局部变量存储在栈结构</font>
- 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。对象的属性（非static）也在堆空间中
- 方法区：类的加载信息、常量池、静态域





# EX-2、`JavaBean`

> ​		用户可以使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的`JSP页面`、`Servlet`、其他`JavaBean`、applet程序或者应用来使用这些对象。
>
> ​		用户可以认为`JavaBean`提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

- `JavaBean`是一种Java语言写成的可重用组件
- 所谓``JavaBean`是指符合如下标准的Java类
	- 类是公共的
	- 有一个无参的公共的构造器
	- 有属性，且有对应的get、set方法



# EX-3 关键字-this

> Java的`this` 和 Python中的`self`一致
>
> - 在类的方法中，使用`this.属性`或`this.方法`的方式，调用当前对象的属性或方法
>
> 但略有不同：
>
> - `this`可以省略
> 	- 通常情况下，我们都选择省略`this`。
> 	- 特殊情况下，我们必须显式的使用`this.变量`，表明此变量是属性，而非形参
>
> - `this`调用构造器
> 	- 在类的构造器中，可以显式的使用`this(形参列表)`方式，调用本类中指定的其他构造器
> 	- 不能循环调用，比如通过`this(形参列表)`调用自己，或者通过调用其他构造器再调用自己
> 	- `this(形参列表)`必须声明在当前构造前的首行
> 		- 构造器内部，最多只能声明一个`this(形参列表)`，用来调用其他构造器



```java
public class PersonTest {
    public static void main(String[] args){
        Person person = new Person("任博",1);
        }
}
class Person{
    String name;
	
    public Person(){
        System.out.println("一号构造器准备启动");
    }
    
	//调用构造器
    public Person(int month){
        this();
        System.out.println("二号构造器准备在"+month+"月完成");
    }
    
    public Person(String name,int month){
        //一个构造器中只能调用一个构造器
        //this();
        //调用含参的构造器
        this(month);
        this.name = name;
        this.getName();
        System.out.println("三号构造器准备完成");
    }
    
    public void getName(){
        System.out.println("我名字是"+this.name);
    }
}
```



# EX-4 关键字-package

1. 为了更好的实现项目中类的管理，提供包的概念
2. 使用package声明类或接口的包，声明在源文件的首行
3. 包，属于==标识符==，遵循标识符的命名规则、命名规范
4. 每`.`一次，就代表一层文件目录，比如`java.util.scen.FinalTest`

5. 同一个包下，不能命名同名的接口、类
	- 不同的包下，可以命名同名的接口、类



# EX-5 关键字-import

1. 在源文件中显式的使用`import`结构导入指定包下的类、接口
2. 声明位置，在包的的声明和类的声明之间
- `import xxx.*`
	- 表示可以导入xxx包下的所有结构
- 如果使用的是`xxx`子包下的结构，则仍需要显式的导入
		- `import java2`，如果要引入`java2`的子包`java3`，还需要`import java2.java3`
- 省略`import`
	- 如果使用的类或接口是`java.lang`包下定义的，则可以省略`import`
		- 使用频率高的类、接口定义在`java.lang`包，比如`String`、`System`
	- 如果使用的类或接口是本包下定义的，则可以省略`import`
- 如果使用了不同包下同名的类，则必须至少有一个类需要以全类名的方式显示
- `import static`，导入指定类或接口中的静态结构（属性、方法）
	- `import static java.lang.System.*;`
		- 导入后，可以直接使用`out.println("");`进行输出
		- 因为out是静态属性





```java
import com.jav2.Bank;
//import com.jav3.Bank;//这样导入，怎么判断是哪个Bank？

public class SteamTest{
    public void static main(String[] args){
        
        Bank banker1 = new Bank(1000);
        
        //全类名的方式
        com.jav3.Bank banker2 = new com.jav3.Bank("杉果",2000);
    }
}
```





# EX-6 MVC设计模式

> MVC是常用的设计模式之一，将整个程序分为三个层次，视图模型层、控制器层、数据模型层。
>
> 这种将程序输入输出、数据处理、数据展示分离开的设计模式，使程序结构灵活清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性

- 模型层  model  处理数据

- 视图层  view  显示数据
- 控制层  controller 处理业务逻辑

![MVC](E:%5CLearning%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5CMVC.png)