> 学习面向对象的三条主线
>
> 1. Java类及类的成员：属性、方法、构造器；代码块、内部类
> 2. 面向对象的三大特征：封装、继承、多态
> 3. 其他关键字



# 前言

> 面向过程（POP）与面向对象（OOP）
>
> - 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做
> - 面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

> 面向对象的两个要素
>
> - 类：对一类事物的描述，是抽象的、概念的定义
> - 对象：是实际存在的该类事物的每个个体，因此也称作实例（instance）



> 面向对象的重点就是类的设计
>
> 类的设计，就是设计类的成员



# 一、类的结构



- 属性，也称作 成员变量 、field 、域、字段
- 方法，也称作 成员方法、函数、method

- 构造器
- 代码块
- 内部类

> 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static）

```java
public class PersonTest{
    public static void main(String[] args){
        //创建Person类的对象
        Person p1 = new Person();
        
        //调用属性
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法
        p1.sleep();
        p1.talk("English");
        
        //将p1变量保存的对象地址值赋给p3
        Person p3 = p1;
        System.out.println(p3.name);//Tom
        
    }
}


class Person{
    //属性
    String name;
    int age = 1;
    boolean isMale;
    
    //方法
    public void eat(){
        String food = "烙饼";//局部变量
        System.out.println("People can eat"+food);
    }
    public void sleep(){
        System.out.println("People can sleep");
    }
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }
}
```





## 1、属性的使用

> 属性（成员变量）  VS  局部变量
>
> 相同点：
>
> ​			声明方式一样；先声明后使用；
>
> 不同点：
>
> 1.声明位置的不同
>
> ​		属性：直接定义在类的一对{ }内
>
> ​		局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
>
> 2.关于权限修饰符不同
>
> ​		属性：可以在声明属性时，指明其权限，使用权限修饰符
>
> ​					常用的权限修饰符：private、public、缺省、protected
>
> ​		局部变量：不可以使用权限修饰符
>
> 3.默认初始化值
>
> ​		属性：类的属性根据其情况，都有默认初始化值
>
> - 整型（`byte`,`int`,`short`,`long`）：0
>
> - 浮点型（`float`,`double`）：0.0
>
> - 字符型（char）：0（或`\u0000`）
>
> - 引用类型（类、数组、接口）：null
>
> 	局部变量：没有默认初始值
>
> - 在调用局部变量前，一定要赋值
>
> - 特别的，形参在调用方法时赋值
>
> 4.在内存中加载的位置
>
> ​	属性：在堆空间中加载（非static）
>
> ​	局部变量：在栈空间中加载



- 类的属性可以为自定义类，`private Account account;`
	- 类似`String name;`
	- 两个类形成关联关系
- 类的属性可以为对象数组。`private Customer[] customers;`
	- 数组里面的元素是Customer类型的

```java
class User{
    //属性
    String name;
    public int age = 1;
    
    public void eat(){
    	String food = "烙饼";//局部变量
    	System.out.println("People can eat"+food);
    }
    
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }  
}
```





## 2、方法的使用

> 1. 方法的声明 ：
>
> 	权限修饰符  返回值类型  方法名（数据类型1 形参1，数据类型2 形参2）{
>
> 	​								方法体
>
> 	}
>
> 2. 常用的权限修饰符：private、public、缺省、protected
>
> 3. 没有返回值用void表示
>
> 4. return关键字，可以用来返回值&结束方法
>
> 5. <font color="red">方法中，不可以定义方法</font>



```java
public class CustomerTest{

    public static void main(String[] args) {
        BuyFood child = new BuyFood();
        child.weight=2.1;
        String food = "bread";
        int price = 1;
       
        System.out.println(child.foodPrice(food,price));//2
    }

}
class BuyFood{
    double weight;
    public int foodPrice(String food,int price){
        
        System.out.println("food "+weight+"kg is enough ");
        System.out.println(food+" is worth five dollars");

        return ++price;
    }
}
```



## 3、构造器

> 构造器的作用：
>
> >  类似`def __init__(self)`
>
> - 创造对象：
>
>   - 创建类的对象：new+构造器
>   - `Person P = new Person()`，`Person()`称作构造器
>
> - 初始化对象的属性
>
>   
>
>   说明：
>
>   1、如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
>
>   2、一旦显式的定义类的构造器，系统不再提供一个默认空参的构造器
>
>   3、定义构造器的格式：            权限修饰符  	类名(形参列表){ }
>
>   4、一个类中定义多个构造器，彼此构成重载
>
>   5、一个类中至少会有一个构造器(如果不定义，系统也强塞一个)
>   
>   6、没有返回值





```java
public class PersonTest{
    //创建类的对象：new + 构造器
    Person P = new Person();
}

class Person{
    //属性
    String name;
    int age;
    
    //构造器
    //名字必须和类名一样
    //有了构造器后，new Person()时，会自动执行构造器内的内容，像 def __init__(self):
    public Person(String n){
        name = n
        System.out.println("构造器1");
    }
    //构造器的重载
    public Person(int n){
        age = n
        System.out.println("构造器2");
    }
    
    //方法
    public void eat(){
        System.out.println("吃饭");
}
```









# 二、万事万物皆对象

> 1.理解万事万物皆对象
>
> - 在Java语言中，我们都将功能、结构封装到类中，通过类的实例化，来调用具体的功能结构
> 	- Scanner、String等
> 	- 文件：File

## 1、对象数组

```java
public class InstanceTest{
    public static void main(String[] args){
        
        //数组元素是Student，如String[] str = new String
        //[]才表示数组,该情况下数组初试化值为null，即[null,null,null,null,null]
        Student[] stus = new Student[5];
        stus[0] = new Student();//数组元素是Student，只能存储Student类型
        
        System.out.println("stus[0].state:"+stus[0].state);
    }
}
class Student{
    int number;
    int state = 1;
    int score;
}
```



## 2、匿名对象

```java
public class InstanceTest{
    public static void main(String[] args){
        //匿名对象,没有给对象命名，直接调用方法
        new Phone().sendEmail();

        new Phone().price=100;
        new Phone().showPrice();//每次对象都是新的
		
        //匿名对象的使用
        SendMessage sendmes = new SendMessage();
        sendmes.show(new Phone());
    }
}

class SendMessage{
    //自定义的类可以用作形参
    public void show(Phone phone){//也可以说把new Phone()命名为形参phone。形参也是局部变量。
        phone.sendEmail();
        phone.showPrice();
    }
}

class Phone{
    double price;
    public void sendEmail(){
        System.out.println("发送邮件");
    }
    public void showPrice(){
        System.out.println("手机价格："+price);
    }
}


```



## 3、方法的重载

> 方法的重载（overload）
>
> 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的<font color="red">参数个数</font>或者<font color="red">参数类型</font>不同即可



```java
class OverLoad{
    //如下的两个方法构成了方法重载
    //根据参数类型来选择调用哪个函数
	public void reverse(int number){
        System.out.println("number:"+number);
    }    
    public void reverse(String number){
        System.out.println("number:"+number);
    }
}
```

- 方法重载的自动类型提升
	- 故调用方法时，不但需要看类的方法名，还要看方法的参数列表

```java
	public class OverLoadTest{
	    public static void main(String[] args){
	        OverLoadTest ovl = new OverLoadTest();
	        ovl.getSum(1,2);//变成了double型
	    }
	    //不注释的话，优先会选int。注释后会去匹配，进行自动类型提升
	//    public getSum(int i , int j){
	//        System.out.println("1");
	//    }
	    public getSum(double i , double j){
	        System.out.println("2");
	    }
	    public getSum(String i , int j){
	        System,out.println("3";)
	    }
	}
```





## 4、可变个数形参

>定义：允许直接定义能和==多个==实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参
>
>- 调用可变数目形参的方法时，传入的参数可以是：0个、1个、2个...
>
>- 如果存在只有一个参数的方法，那么会优先识别那个方法，而不是可变数目形参的方法



```java
public class MethodArgsTest{
    //1.可变数目的形参
    public void show(String ... strs){
    	//使用方式和数组的使用方式一样
    	//区别是，与传入数组类型相比，本方法参数类型不用定义为数组，如show(new String[]{1,2,3})。可以直接为show(1,2,3)
        //本方法的传入参数也可以为数组类型,如show(new String[]{1,2,3})
        System.out.println("4");
    }
    
    //2. 与1构成重载
    public void show(String strs){
        System.out.println("5");
    }
    
    //3.报错，与1的不构成重载，不能共存
    //因为JDK1.5以前是用数组传入多个值
    public void show(String[] strs){
        System.out.println("6");
    }
    
    //4.可变数目参数必须放在最后
    public void show(int i,String ... strs){
        System.out.println("6");
    }
}
```



## 5、方法参数的值传递机制

> - 形参：方法声明时的参数
>
> - 实参：方法调用时实际传给形参的参数值
>
> 	```java
> 	int a = 0;
> 	show(a);//a还是实参
> 	public void show(a){//a是形参
> 	    return;
> 	}
> 	//相当于实参a赋值给形参a
> 	```
>
> 	

### 值传递机制

- Java里方法的参数传递方式只有一种：<font color="red">值传递</font>。

- 形参是基本数据类型：将实参（基本数据类型变量）的`数据值`传给形参
- 形参是引用数据类型：将实参（引用数据类型变量）的`地址值`传给形参



### 变量的赋值

- 如果A变量是基本数据类型，`B=A`，此时赋值的是A变量保存的数据值
- 如果A变量是引用数据类型，`B=A`，此时赋值的是A变量保存的数据的地址值

```java
//附加题
public class Test{
    public static void main(String[] args){
        int a=10;
        int b=10;
        //需要在method方法调用后，仅打印出a=100，b=200，写出method的代码
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }
    //方法一
    public static void method(int a,int b){
        a=a*10;
        b=b*20;
        System.out.println("a="+a);
        System.out.println("b="+b);
        System.exit(0);//退出程序。终止JVM的执行
    }
    //方法二,重写打印流
    public static void method(int a,int b){
        PrintStream ps = new PrintStream(System.out){
            @Override
            public void println(String x){
                if ("a=10".equals(x)){
                    x = "a=100";
                } 
                else if ("b=10".equals(x)){
                    x = "b=200";
                }
                super.println(x);
            }
        };
        System.setOut(ps);
    }
}
```

# 三、关键字

## 关键字-this

> Java的`this` 和 Python中的`self`一致

在类的方法中，使用`this.属性`或`this.方法`的方式，调用当前对象的属性或方法

 但略有不同：

 - `this`可以省略
	 	- 通常情况下，我们都选择省略`this`。
	  - 特殊情况下，我们必须显式的使用`this.变量`，表明此变量是属性，而非形参

 - `this`调用构造器
	 	- 在类的构造器中，可以显式的使用`this(形参列表)`方式，调用本类中指定的其他构造器
	 	- 不能循环调用，比如通过`this(形参列表)`调用自己，或者通过调用其他构造器再调用自己
	  - `this(形参列表)`必须声明在当前构造前的首行
					   - 构造器内部，最多只能声明一个`this(形参列表)`，用来调用其他构造器



```java
public class PersonTest {
    public static void main(String[] args){
        Person person = new Person("任博",1);
        }
}
class Person{
    String name;
	
    public Person(){
        System.out.println("一号构造器准备启动");
    }
    
	//调用构造器
    public Person(int month){
        this();
        System.out.println("二号构造器准备在"+month+"月完成");
    }
    
    public Person(String name,int month){
        //一个构造器中只能调用一个构造器
        //this();
        //调用含参的构造器
        this(month);
        this.name = name;
        this.getName();
        System.out.println("三号构造器准备完成");
    }
    
    public void getName(){
        System.out.println("我名字是"+this.name);
    }
}
```







## 关键字-package

1. 为了更好的实现项目中类的管理，提供包的概念
2. 使用package声明类或接口的包，声明在源文件的首行
3. 包，属于==标识符==，遵循标识符的命名规则、命名规范
4. 每`.`一次，就代表一层文件目录，比如`java.util.scen.FinalTest`

5. 同一个包下，不能命名同名的接口、类
	- 不同的包下，可以命名同名的接口、类









## 关键字-import

1. 在源文件中显式的使用`import`结构导入指定包下的类、接口
2. 声明位置，在包的的声明和类的声明之间
- `import xxx.*`
	- 表示可以导入`xxx`包下的所有结构
- 如果使用的是`xxx`子包下的结构，则仍需要显式的导入
		- `import java2`，如果要引入`java2`的子包`java3`，还需要`import java2.java3`
- 省略`import`
	- 如果使用的类或接口是`java.lang`包下定义的，则可以省略`import`
		- 使用频率高的类、接口定义在`java.lang`包，比如`String`、`System`
	- 如果使用的类或接口是本包下定义的，则可以省略`import`
- 如果使用了不同包下同名的类，则必须至少有一个类需要以全类名的方式显示
- `import static`，导入指定类或接口中的静态结构（属性、方法）
	- `import static java.lang.System.*;`
		- 导入后，可以直接使用`out.println("");`进行输出
		- 因为out是静态属性





```java
import com.jav2.Bank;
//import com.jav3.Bank;//这样导入，怎么判断是哪个Bank？

public class SteamTest{
    public void static main(String[] args){
        
        Bank banker1 = new Bank(1000);
        
        //全类名的方式
        com.jav3.Bank banker2 = new com.jav3.Bank("杉果",2000);
    }
}
```



## 关键字-super

> 方法重写后，如果还想使用父类的方法，可以使用`super`关键字

- 可以用`super.属性`，`super.方法`来调用父类的属性、方法
	- 类似`this`，通常情况下调用父类的属性、方法，省略了`super`
- 当子类和父类定义了同名的属性和方法时，想要调用父类的属性、方法，必须显式的使用`super`
	- 通常开发中不会出现同名的属性
	- `super`会先在直接父类中寻找，若没有，再向上往间接父类中找
- `super(参数列表)`调用构造器
	- 必须声明在子类构造器的首行 
	- 我们在类的构造器中，针对`this(形参列表)`或`super(形参列表)`，只能二选一，不能同时出现
		- 因为`this`调用构造器也要求放首行
	- 在构造器的首行，没有显式的声明`this(形参列表)`或`super(形参列表)`，则默认调用父类中空参的构造器：`super()`
		- 一个类的构造器首行不是`this`就是`super`



> 假如父类中没有空参构造器，
>
> - 子类刚写完第一行定义就会报错
> 	- 因为系统会默认给子类一个空参构造器，该构造器首行会自动调用父类的空参构造器失败，就会报错
> - 子类的空参构造器报错
> 	- 因为调用不了父类的空参构造器

​	

```java
class Student extends Person{
    String major;
    int id；
        
    //构造器
    public Student(){
        //即使没用使用this和super，也会默认调用super();
    }
    
    public Student(String major,String name){
        super(name);
        this.major=major;
    }
    
    //方法重写
    @Override
    public void eat(){
        System.out.println("我爱吃饭");
    }
    
    //对于不同名的属性，this和super的功用相同
    public void showBasic(){
        System.out.println("name"+this.name+"age"+super.age);
    }
    
    //对于同名的属性，可以用this和super加以区分
    //子类id表学生证号，父类id表身份证号
    public void showBasic(){
        System.out.println("学生证号："+this.id+"身份证号："+super.id);
    }
}
```











# 面向对象特征之一：封装

> 一、为什么要封装？
>
> - 我要用洗衣机，只要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗
>
> - 我们的程序追求“高内聚，低耦合”
> 	- 高内聚：类的内部操作细节自己完成，不允许外部干涉
> 	- 低耦合：仅对外暴露少量的方法用于是用
> - 隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性
> - 把该隐藏的隐藏，该暴露的暴露，就是封装性的设计思想

> 封装性的举例：
>
> 将类的属性X私有化（private），同时提供公共的（public）方法来获取和设置此属性的值



## 1、描述封装性

Java提供4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小



## 2、四种权限修饰符

Java规定的4种权限修饰符（从小到大排列）

- private、缺省(默认)、protected、public

| 修饰符     | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| ---------- | ------ | -------- | ------------ | ---------- |
| private    | Yes    |          |              |            |
| 缺省(默认) | Yes    | Yes      |              |            |
| protected  | Yes    | Yes      | Yes          |            |
| public     | Yes    | Yes      | Yes          | Yes        |

> 不同包的子类指的是，不同包下，以该类为父类的子类

- 4种权限可以用来修饰类的内部结构：属性、方法、构造器、内部类

- 只可以用`public `和 `缺省（默认）`来修饰类
  - public类，可以在任意地方被访问
  - 缺省的类，只可以被同一个包内部的类访问

- ==即便引用该包，也不能在其他包下使用该包下缺省修饰的类==

```java
public class OrderTest{
    private int number;
    
    private void methodPrivate(){
        System.out.println("private");
    }
    void methodDefault(){
        System.out.println("default");
    }
    public void methodPublic(){
        System.out.println("public");
    }
}
class OrderTestEx{
    int age;
    public int money;
}
```







# 面向对象特征之二：继承性

>继承性的好处：
>
>- 减少了代码的冗余，提高了代码的复用性
>- 便于功能的扩展
>- 为之后多态性的使用，提供了前提



>继承格式：`class A extends B{}`
>
>- A：子类、派生类、subclass
>
>- B：父类、超类、基类、superclass



> 子类A获取父类B所声明的<font color="red">所有</font>属性、方法
>
> - 子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的拓展
> - 子类不能直接访问父类中私有的成员变量和方法
>
> - 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中的私有结构。只是因为封装性的影响，使得子类不能直接调用父类的结构。
>   - 可以在父类中public方法中调用private方法，再在子类中调用该public方法，发现private方法也执行了，证明子类仍然获取了父类中的结构。



> Java只支持单继承和多层继承，不允许多重继承
>
> - 一个子类只能有一个父类👉单继承
> - 一个父类可以派生出多个子类👉多层继承
> - 不允许一个子类同时继承多个父类👉多重继承（C++允许）
>
> 子类直接继承的父类，称为：直接父类
>
> 子类间接继承的父类，称为简介父类（子类父类的父类）



```java
//Person 是父类
public class Student extends Person {
//    String name;//父类里已经定义过
//    int age;
    String major;

    //构造器不能删
    public Student(){
    }
    public Student(String name, int age, String major){
        this.name = name;
        this.age = age;
        this.major = major;
    }
    
    //在父类里面定义过，删除
//    public void eat(){
//        System.out.println("吃饭");
//    }
    
    public void study(){
        System.out.println("学习");
    }
}
```





## 1、Object类

1. 如果没有显式的声明一个类的父类的话，则此类继承于`java.lang.Object`类

2. 所有的Java类，都直接或间接继承于`java.lang.Object`类
3. 意味着所有Java类都有`java.lang.Object`类的功能







## 2、方法的重写

> 子类和父类中同名同参数的方法，要么都声明为`非static`的，要么都声明为`static`
>
> - `非static`的方法才可以重写
>
> - `static`方法不可以重写，不可以被覆盖，会随着类的加载而加载，这已经不叫重写了
>
> 	
>
> 一般在重写的方法前加上@Override



1、重写：子类继承父类后，可以对父类中同名同参数的方法，进行覆盖操作

2、应用：重写以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法

3、重写的规定

 ​			方法的声明：	权限修饰符	返回值类型	方法名（形参列表） throws  异常的类型{

 ​															方法体

 ​										}

 - 子类重写方法的<font color='red'>方法名和形参列表</font>，要和父类中被重写方法的<font color='red'>方法名和形参列表</font>相同
 - 子类重写方法的权限修饰符，不能小于父类被重写方法的权限修饰符
   - 特殊情况，子类不能重写父类中声明为`private`权限的方法
   - 一般，重写方法的权限修饰符和被重写方法的一致
 - 返回值类型
   - 父类被重写方法的返回值类型是`void`类型，子类重写方法的返回值类型只能是`void`类型
   - 父类被重写方法的返回值类型是`A`类型，子类重写方法的返回值类型可以是`A`类型或`A`类的子类
   - 父类被重写方法的返回值类型是基本类型`(如:int)`，子类重写方法的返回值类型必须是相同的基本类型`(如:int)`
- 子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型



```java
public class Student extends Person{
    String major;
    
    //构造器
    public Student(){
  
    }
    public Student(String major){
        this.major=major;
    }
    //父类Person已经存在方法 public void eat(String food)
    @Override
    public void eat(String food){
        System.out.println("我爱吃"+food);
    }
}
```





## 3、子类对象实例化的全过程



- 从结果上看

  - 子类继承父类以后，就获得了父类中声明的属性和方法
  - 创建子类的对象时，在堆空间，就会加载所有父类中声明的属性

- 从过程上看

  ​		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器...直到调用`java.lang.Object`类中空参的构造器为止。

  ​		正因为加载过所有父类的结构，所以才可以看见内存中有父类中的结构，子类对象才可以调用

  > 为什么会直接&间接的调用父类的构造器?
  >
  > ​		因为子类的构造器首行只能用`this`或`super`调用构造器
  >
  > ​		只有子类存在两个及以上构造器时，子类构造器中才可以用`this`调用其他构造器，然而这也必会存在一个构造器不能用`this`，故子类必会存在一个构造器使用`super`（或者系统默认调用）。



- ==明确：==

  虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象













# 面向对象特征之三：多态性

> 什么是多态性：
>
> ​		对象的多态性，父类的引用指向子类的对象



> 多态的使用——虚拟方法使用
>
> ​			` Person p2 = new Man();`
>
> - 在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法
>   - 如`p2.eat()`，编译的时候，会检查父类中有没有`eat()`这个方法，追踪该方法也会指向父类。但是实际执行，是执行子类中的`eat()`
>   - 编译看左边（即`Person`类），运行看右边（即`Man`类）

> 多态的使用前提
>
> 1. 要有类的继承关系
> 2. 要有方法的重写，否则就没有必要`new`子类对象

```java
public class PersonTest{
    public static void main(String[] args){
        //Person 是 Man 的父类
        Person p1 = new Person();
        p1.eat();
        
        Man m1 = new Man();
        m1.age = 25;
        m1.eat();
        m1.earnMoney();
        
        //********************************************
        //对象的多态性，父类的引用指向子类的对象
        Person p2 = new Man();
        
        //多态的使用
        //当调用子父类同名同参数的方法时，实际执行的是子类重写以后的方法————虚拟方法使用
        p2.eat();
        
        //编译过不去，父类没有该子类特有的方法
        //p2.earnMoney();
    }
}
```



- 多态性的使用

  举例一

```java
public class AnimalTest {
    
    public static void main(String[] args) {
        
        AnimalTest a1 = new AnimalTest();
        
        //要求传入Animal，但是传入Dog，这就是多态
        //不再需要再为Dog，Cat造很多重载的方法，
        a1.func(new Dog());
        a1.func(new Cat());
       
    }
    public void func(Animal animal){//Animal animal = new Dog()
        animal.eat();
    }

}

class Animal{
    public void eat(){
        System.out.println("Animal eat");
    }
}

class Dog extends Animal{
    public void eat(){
        System.out.println("Dog eat");
    }
}

class Cat extends Animal{
    public void eat(){
        System.out.println("Cat eat");
    }
}
```

​		举例二

```java
class Order{
    public void method(Object obj){
        //可以传多种子类，省去了写多个重载的方法
        //可以只写一次子类的重写方法
        
        //重写obj.method1();
        //重写obj.method2();
        
    }
}
```








































# EX-1、JVM内存结构与对象解析

![](E:%5CLearning%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5Cimage-20201108154358774.png)

- 虚拟机栈，即平时所说的栈结构。<font color="red">我们平时将局部变量存储在栈结构</font>
- 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。对象的属性（非static）也在堆空间中
- 方法区：类的加载信息、常量池、静态域





# EX-2、`JavaBean`

> ​		用户可以使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的`JSP页面`、`Servlet`、其他`JavaBean`、applet程序或者应用来使用这些对象。
>
> ​		用户可以认为`JavaBean`提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

- `JavaBean`是一种Java语言写成的可重用组件
- 所谓``JavaBean`是指符合如下标准的Java类
	- 类是公共的
	- 有一个无参的公共的构造器
	- 有属性，且有对应的get、set方法















# EX-3 MVC设计模式

> MVC是常用的设计模式之一，将整个程序分为三个层次，视图模型层、控制器层、数据模型层。
>
> 这种将程序输入输出、数据处理、数据展示分离开的设计模式，使程序结构灵活清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性

- 模型层  model  处理数据

- 视图层  view  显示数据
- 控制层  controller 处理业务逻辑

![MVC](E:%5CLearning%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5CMVC.png)