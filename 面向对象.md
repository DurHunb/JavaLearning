> ​     学习面向对象的三条主线
>
> 1. Java类及类的成员：属性、方法、构造器；代码块、内部类
> 2. 面向对象的三大特征：封装、继承、多态
> 3. 其他关键字



# 前言

> 面向过程（POP）与面向对象（OOP）
>
> - 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做
> - 面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

> 面向对象的两个要素
>
> - 类：对一类事物的描述，是抽象的、概念的定义
> - 对象：是实际存在的该类事物的每个个体，因此也称作实例（instance）



> 面向对象的重点就是类的设计
>
> 类的设计，就是设计类的成员



# 一、类的结构



- 属性，也称作 成员变量 、field 、域、字段
- 方法，也称作 成员方法、函数、method

- 构造器
- 代码块
- 内部类

> 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static）

```java
public class PersonTest{
    public static void main(String[] args){
        //创建Person类的对象
        Person p1 = new Person();
        
        //调用属性
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法
        p1.sleep();
        p1.talk("English");
        
        //将p1变量保存的对象地址值赋给p3
        Person p3 = p1;
        System.out.println(p3.name);//Tom
        
    }
}


class Person{
    //属性
    String name;
    int age = 1;
    boolean isMale;
    
    //方法
    public void eat(){
        String food = "烙饼";//局部变量
        System.out.println("People can eat"+food);
    }
    public void sleep(){
        System.out.println("People can sleep");
    }
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }
}
```





## 1、属性的使用

> 属性（成员变量）  VS  局部变量
>
> 相同点：
>
> ​			声明方式一样；先声明后使用；
>
> 不同点：
>
> 1.声明位置的不同
>
> ​		属性：直接定义在类的一对{ }内
>
> ​		局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
>
> 2.关于权限修饰符不同
>
> ​		属性：可以在声明属性时，指明其权限，使用权限修饰符
>
> ​					常用的权限修饰符：private、public、缺省、protected
>
> ​		局部变量：不可以使用权限修饰符
>
> 3.默认初始化值
>
> ​		属性：类的属性根据其情况，都有默认初始化值
>
> - 整型（`byte`,`int`,`short`,`long`）：0
>
> - 浮点型（`float`,`double`）：0.0
>
> - 字符型（char）：0（或`\u0000`）
>
> - 引用类型（类、数组、接口）：null
>
> 	局部变量：没有默认初始值
>
> - 在调用局部变量前，一定要赋值
>
> - 特别的，形参在调用方法时赋值
>
> 4.在内存中加载的位置
>
> ​	属性：在堆空间中加载（非static）
>
> ​	局部变量：在栈空间中加载



- 类的属性可以为自定义类，`private Account account;`
	- 类似`String name;`
	- 两个类形成关联关系
- 类的属性可以为对象数组。`private Customer[] customers;`
	- 数组里面的元素是Customer类型的

```java
class User{
    //属性
    String name;
    public int age = 1;
    
    public void eat(){
    	String food = "烙饼";//局部变量
    	System.out.println("People can eat"+food);
    }
    
    public void eat(String language){//language：形参，也是局部变量
        System.out.println("People can speak"+language);
    }  
}
```





## 2、方法的使用

> 1. 方法的声明 ：
>
> 	权限修饰符  返回值类型  方法名（数据类型1 形参1，数据类型2 形参2）{
>
> 	​								方法体
>
> 	}
>
> 2. 常用的权限修饰符：private、public、缺省、protected
>
> 3. 没有返回值用void表示
>
> 4. return关键字，可以用来返回值&结束方法
>
> 5. <font color="red">方法中，不可以定义方法</font>



```java
public class CustomerTest{

    public static void main(String[] args) {
        BuyFood child = new BuyFood();
        child.weight=2.1;
        String food = "bread";
        int price = 1;
       
        System.out.println(child.foodPrice(food,price));//2
    }

}
class BuyFood{
    double weight;
    public int foodPrice(String food,int price){
        
        System.out.println("food "+weight+"kg is enough ");
        System.out.println(food+" is worth five dollars");

        return ++price;
    }
}
```



## 3、构造器

> 构造器的作用：
>
> >  类似`def __init__(self)`
>
> - 创造对象：
>
>   - 创建类的对象：new+构造器
>   - `Person P = new Person()`，`Person()`称作构造器
>
> - 初始化对象的属性
>
>   
>
>   说明：
>
>   1、如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
>
>   2、一旦显式的定义类的构造器，系统不再提供一个默认空参的构造器
>
>   3、定义构造器的格式：            权限修饰符  	类名(形参列表){ }
>
>   4、一个类中定义多个构造器，彼此构成重载
>
>   5、一个类中至少会有一个构造器(如果不定义，系统也强塞一个)
>   
>   6、没有返回值





```java
public class PersonTest{
    //创建类的对象：new + 构造器
    Person P = new Person();
}

class Person{
    //属性
    String name;
    int age;
    
    //构造器
    //名字必须和类名一样
    //有了构造器后，new Person()时，会自动执行构造器内的内容，像 def __init__(self):
    public Person(String n){
        name = n
        System.out.println("构造器1");
    }
    //构造器的重载
    public Person(int n){
        age = n
        System.out.println("构造器2");
    }
    
    //方法
    public void eat(){
        System.out.println("吃饭");
}
```



## 4、代码块

> 1、代码块的作用：用来初始化类、对象
>
> 2、代码块只能用`static`修饰
>
> 3、分类：静态代码块、非静态代码块
>
> - 静态代码块
>   - 内部可以使用输出语句
>   - 随着<font color='red'>类的创建</font>而执行，而且只执行一次
>   - 作用：初始化类的信息
>   - 如果一个类中定义了多个静态代码块，则按照声明先后顺序执行（没有必要多个）
>   - 静态代码块可以调用静态的属性、静态的方法，不可以调用非静态结构
> - 非静态代码块
>   - 内部可以使用输出语句
>   - 随着<font color='red'>对象的加载</font>而执行，每创建一次就执行一次
>   - 作用：可以在创建对象时，对对象的属性进行初始化
>   - 如果一个类中定义了多个非静态代码块，则按照声明先后顺序执行（没有必要多个）
>   - 非静态代码块，可以自由调用静态与非静态结构
>
> 



```java
public class BlockTest{
    public static void main(String[] args){
        Person p1 = new Person();
    }
}

class Person{
    //属性
    String name;
    int age;
    
    //构造器
    public Person(){
    }
	
    //静态代码块
    static{
        System.out.println("hello,static-1");  
        //只能调用静态结构
        show();
    }
    static{
        System.out.println("hello,static-2");  	  
    }
    
    //非静态代码块
    {
        System.out.println("hello,NO static");
        //静态非静态结构都可以调
        eat();
        show();
    }
    
    //方法
    public void eat(){
        System.out.println("吃饭");
    public static show(){
        System.out.println("秀");
    }
}
```







# 二、万事万物皆对象

> 1.理解万事万物皆对象
>
> - 在Java语言中，我们都将功能、结构封装到类中，通过类的实例化，来调用具体的功能结构
> 	- Scanner、String等
> 	- 文件：File

## 1、对象数组

```java
public class InstanceTest{
    public static void main(String[] args){
        
        //数组元素是Student，如String[] str = new String
        //[]才表示数组,该情况下数组初试化值为null，即[null,null,null,null,null]
        Student[] stus = new Student[5];
        stus[0] = new Student();//数组元素是Student，只能存储Student类型
        
        System.out.println("stus[0].state:"+stus[0].state);
    }
}
class Student{
    int number;
    int state = 1;
    int score;
}
```



## 2、匿名对象

```java
public class InstanceTest{
    public static void main(String[] args){
        //匿名对象,没有给对象命名，直接调用方法
        new Phone().sendEmail();

        new Phone().price=100;
        new Phone().showPrice();//每次对象都是新的
		
        //匿名对象的使用
        SendMessage sendmes = new SendMessage();
        sendmes.show(new Phone());
    }
}

class SendMessage{
    //自定义的类可以用作形参
    public void show(Phone phone){//也可以说把new Phone()命名为形参phone。形参也是局部变量。
        phone.sendEmail();
        phone.showPrice();
    }
}

class Phone{
    double price;
    public void sendEmail(){
        System.out.println("发送邮件");
    }
    public void showPrice(){
        System.out.println("手机价格："+price);
    }
}


```



## 3、方法的重载

> 方法的重载（overload）
>
> 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的<font color="red">参数个数</font>或者<font color="red">参数类型</font>不同即可
>
> 方法重载需要满足以下几个**条件**：
>
> 1. 在同一个类中
> 2. 方法的名称相同
> 3. 参数列表不同（参数列表的参数的类型，个数，顺序不同）
>
> 方法重载有以下**特点**：
>
> 1. 权限修饰符和返回值类型无关
> 2. 与异常无关



```java
class OverLoad{
    //如下的两个方法构成了方法重载
    //根据参数类型来选择调用哪个函数
	public void reverse(int number){
        System.out.println("number:"+number);
    }    
    public void reverse(String number){
        System.out.println("number:"+number);
    }
}
```

- 方法重载的自动类型提升
	- 故调用方法时，不但需要看类的方法名，还要看方法的参数列表

```java
	public class OverLoadTest{
	    public static void main(String[] args){
	        OverLoadTest ovl = new OverLoadTest();
	        ovl.getSum(1,2);//变成了double型
	    }
	    //不注释的话，优先会选int。注释后会去匹配，进行自动类型提升
	//    public getSum(int i , int j){
	//        System.out.println("1");
	//    }
	    public getSum(double i , double j){
	        System.out.println("2");
	    }
	    public getSum(String i , int j){
	        System,out.println("3";)
	    }
	}
```





## 4、可变个数形参

>定义：允许直接定义能和==多个==实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参
>
>- 调用可变数目形参的方法时，传入的参数可以是：0个、1个、2个...
>
>- 如果存在只有一个参数的方法，那么会优先识别那个方法，而不是可变数目形参的方法



```java
public class MethodArgsTest{
    //1.可变数目的形参
    public void show(String ... strs){
    	//使用方式和数组的使用方式一样
    	//区别是，与传入数组类型相比，本方法传入的参数类型不用定义为数组，如show(new String[]{1,2,3})。可以直接为show(1,2,3)
        //本方法的传入参数也可以为数组类型,如show(new String[]{1,2,3})
        System.out.println("4");
    }
    
    //2. 与1构成重载
    public void show(String strs){
        System.out.println("5");
    }
    
    //3.报错，与1的不构成重载，不能共存
    //因为JDK1.5以前是用数组传入多个值，
    //可以认为show(String[] strs)和show(String ... strs)等价
    public void show(String[] strs){
        System.out.println("6");
    }
    
    //4.可变数目参数必须放在最后
    public void show(int i,String ... strs){
        System.out.println("6");
    }
}
```



## 5、方法参数的值传递机制

> - 形参：方法声明时的参数
>
> - 实参：方法调用时实际传给形参的参数值
>
> 	```java
> 	int a = 0;
> 	show(a);//a还是实参
> 	public void show(a){//a是形参
> 	    return;
> 	}
> 	//相当于实参a赋值给形参a
> 	```
>
> 	

### 值传递机制

- Java里方法的参数传递方式只有一种：<font color="red">值传递</font>。

- 形参是基本数据类型：将实参（基本数据类型变量）的`数据值`传给形参
- 形参是引用数据类型：将实参（引用数据类型变量）的`地址值`传给形参



### 变量的赋值

- 如果A变量是基本数据类型，`B=A`，此时赋值的是A变量保存的数据值
- 如果A变量是引用数据类型，`B=A`，此时赋值的是A变量保存的数据的地址值

```java
//附加题
public class Test{
    public static void main(String[] args){
        int a=10;
        int b=10;
        //需要在method方法调用后，仅打印出a=100，b=200，写出method的代码
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }
    //方法一
    public static void method(int a,int b){
        a=a*10;
        b=b*20;
        System.out.println("a="+a);
        System.out.println("b="+b);
        System.exit(0);//退出程序。终止JVM的执行
    }
    //方法二,重写打印流
    public static void method(int a,int b){
        PrintStream ps = new PrintStream(System.out){
            @Override
            public void println(String x){
                if ("a=10".equals(x)){
                    x = "a=100";
                } 
                else if ("b=10".equals(x)){
                    x = "b=200";
                }
                super.println(x);
            }
        };
        System.setOut(ps);
    }
}
```









# 三、关键字



## 关键字-this

> Java的`this` 和 Python中的`self`一致

在类的方法中，使用`this.属性`或`this.方法`的方式，调用当前对象的属性或方法

 但略有不同：

 - `this`可以省略
	 	- 通常情况下，我们都选择省略`this`。
	  - 特殊情况下，我们必须显式的使用`this.变量`，表明此变量是属性，而非形参

 - `this`调用构造器
	 	- 在类的构造器中，可以显式的使用`this(形参列表)`方式，调用本类中指定的其他构造器
	 	- 不能循环调用，比如通过`this(形参列表)`调用自己，或者通过调用其他构造器再调用自己
	  - `this(形参列表)`必须声明在当前构造前的首行
																															   - 构造器内部，最多只能声明一个`this(形参列表)`，用来调用其他构造器



```java
public class PersonTest {
    public static void main(String[] args){
        Person person = new Person("任博",1);
        }
}
class Person{
    String name;
	
    public Person(){
        System.out.println("一号构造器准备启动");
    }
    
	//调用构造器
    public Person(int month){
        this();
        System.out.println("二号构造器准备在"+month+"月完成");
    }
    
    public Person(String name,int month){
        //一个构造器中只能调用一个构造器
        //this();
        //调用含参的构造器
        this(month);
        this.name = name;
        this.getName();
        System.out.println("三号构造器准备完成");
    }
    
    public void getName(){
        System.out.println("我名字是"+this.name);
    }
}
```







## 关键字-package

1. 为了更好的实现项目中类的管理，提供包的概念
2. 使用package声明类或接口的包，声明在源文件的首行
3. 包，属于==标识符==，遵循标识符的命名规则、命名规范
4. 每`.`一次，就代表一层文件目录，比如`java.util.scen.FinalTest`

5. 同一个包下，不能命名同名的接口、类
	- 不同的包下，可以命名同名的接口、类









## 关键字-import

1. 在源文件中显式的使用`import`结构导入指定包下的类、接口
2. 声明位置，在包的的声明和类的声明之间
- `import xxx.*`
	- 表示可以导入`xxx`包下的所有结构
- 如果使用的是`xxx`子包下的结构，则仍需要显式的导入
		- `import java2`，如果要引入`java2`的子包`java3`，还需要`import java2.java3`
- 省略`import`
	- 如果使用的类或接口是`java.lang`包下定义的，则可以省略`import`
		- 使用频率高的类、接口定义在`java.lang`包，比如`String`、`System`
	- 如果使用的类或接口是本包下定义的，则可以省略`import`
- 如果使用了不同包下同名的类，则必须至少有一个类需要以全类名的方式显示
- `import static`，导入指定类或接口中的静态结构（属性、方法）
	- `import static java.lang.System.*;`
		- 导入后，可以直接使用`out.println("");`进行输出
		- 因为out是静态属性





```java
import com.jav2.Bank;
//import com.jav3.Bank;//这样导入，怎么判断是哪个Bank？

public class SteamTest{
    public void static main(String[] args){
        
        Bank banker1 = new Bank(1000);
        
        //全类名的方式
        com.jav3.Bank banker2 = new com.jav3.Bank("杉果",2000);
    }
}
```



## 关键字-super

> 方法重写后，如果还想使用父类的方法，可以使用`super`关键字

- 可以用`super.属性`，`super.方法`来调用父类的属性、方法
	- 类似`this`，通常情况下调用父类的属性、方法，省略了`super`
- 当子类和父类定义了同名的属性和方法时，想要调用父类的属性、方法，必须显式的使用`super`
	- 通常开发中不会出现同名的属性
	- `super`会先在直接父类中寻找，若没有，再向上往间接父类中找
- `super(参数列表)`调用构造器
	- 必须声明在子类构造器的首行 
	- 我们在类的构造器中，针对`this(形参列表)`或`super(形参列表)`，只能二选一，不能同时出现
		- 因为`this`调用构造器也要求放首行
	- 在构造器的首行，没有显式的声明`this(形参列表)`或`super(形参列表)`，则默认调用父类中空参的构造器：`super()`
		- 一个类的构造器首行不是`this`就是`super`



> 假如父类中没有空参构造器，
>
> - 子类刚写完第一行定义就会报错
> 	- 因为系统会默认给子类一个空参构造器，该构造器首行会自动调用父类的空参构造器失败，就会报错
> - 子类的空参构造器报错
> 	- 因为调用不了父类的空参构造器

​	

```java
class Student extends Person{
    String major;
    int id；
        
    //构造器
    public Student(){
        //即使没用使用this和super，也会默认调用super();
    }
    
    public Student(String major,String name){
        super(name);
        this.major=major;
    }
    
    //方法重写
    @Override
    public void eat(){
        System.out.println("我爱吃饭");
    }
    
    //对于不同名的属性，this和super的功用相同
    public void showBasic(){
        System.out.println("name"+this.name+"age"+super.age);
    }
    
    //对于同名的属性，可以用this和super加以区分
    //子类id表学生证号，父类id表身份证号
    public void showBasic(){
        System.out.println("学生证号："+this.id+"身份证号："+super.id);
    }
}
```





## 关键字-static

> 当编写一个类时，只有通过`new`才会产生对象，这时系统分配内存空间给对象，其方法才可以被外界调用。
>
> 我们希望，无论是否产生了对象，或者无论产生了多少对象，<font color='red'>某些特定的数据在内存空间中只有一份</font>。
>
> 例如：每一个中国人都共享一个国家名称，不必在每一个中国人的实例对象中，都单独分配一个用于表示国家的变量



`static`关键字的使用

- `static`可以用来修饰：属性、方法、代码块、内部类

- 类与对象的调用权限

  - 可以直接通过<font color='red'>类</font>调用<font color='red'>静态变量</font>和<font color='red'>静态方法</font>，不可以直接通过<font color='red'>类</font>调用<font color='red'>实例变量</font>和<font color='red'>非静态方法</font>
  - 可以直接通过<font color='red'>对象</font>调用<font color='red'>静态变量</font>和<font color='red'>静态方法</font>，可以直接通过<font color='red'>对象</font>调用<font color='red'>实例变量</font>和<font color='red'>非静态方法</font>

- 使用`static`修饰属性：静态变量（类变量）

  - 按是否使用`static`修饰，可以分为<font color='red'>静态变量</font>与<font color='red'>实例变量</font>

  - 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。

  	​					当修改其中一个对象的非静态属性时，不会导致其他对象中同样的属性被修改

  - 静态变量：我们创建了类的多个对象，多个对象共用同一个静态变量。

    ​					当修改其中一个对象的静态属性时，其他对象调用此静态变量也是修改过的。

    - 静态变量随着类的加载而加载。可以直接通过	"类.静态变量"（`man.nation="中国"`)	调用。
    - 静态变量的加载要早于对象的创建
    - 由于类只加载一次，所以静态变量也只加载一次，存在方法区的静态域中
    
  - 静态变量与实例变量的内存解析

<img src="D:\ForLife\Learning\面向对象.assets\image-20201130153954147.png" alt="image-20201130153954147" style="zoom:50%;" />



- 使用`static`修饰方法：静态方法

  - 随着类的加载而加载。可以直接通过	"类.静态方法"（`man.show()`)	调用。

  - 静态方法中，只能调用静态的方法和属性

    非静态方法中，既可以调用非静态的方法和属性，也可以调用静态的方法和属性

  - 静态方法中，不能使用`this`，`super`

- 一个属性时候要设置为`static` ？

  - 多个对象共享的属性，设置为`static`
    - 如id的设置，可以设置`private static int init=1001;`，之后每次++
  - 类中的常量设置为`static`
- 一个方法是否要设置为`static` ?

  - 操作静态属性的方法，设置为`static`
  - 工具类的方法，习惯上设置为`static`，如Math、Arrays、Collections



```java
public class People{
    int name;
    static String nation; 
    
    public static void show(){
        //可以调用静态结构
        System.out.println(nation);//nation相当于People.nation
        walk();
        //不可以调用费静态结构
        //name = "Tom";
    }
    
    public static void walk(){
        System.out.println("walk");       
    }
}
```





## 关键字-final



- `final`可以用来修饰的结构：类、方法、变量
- `final`用来修饰一个类：此类不能被其他类所继承。
  - 如：`String`类，`System`类，

- `final`用来修饰方法：表示此方法不可以被重写
  - 如`Object`类的`getClass()`
- `final`用来修饰变量：此时变量称为一个常量
  - 修饰属性，可以考虑对`final`变量的赋值位置：
    - 显式初始化、代码块中初始化、构造器中初始化
    - 默认初始化、方法内赋值不可以
  - 修饰局部变量
    - 尤其是`final`修饰形参，表明此形参是一个常量。
    - 赋值以后，只能在方法体内部调用，不能重新赋值
- `static final `用来修饰属性：全局常量

```java
public class FinalTest{
    
}
//不能被其他类继承
final class FinalA{
    final int LEFT = 0; 
    
    //在代码块里赋值了
    final int RIGHT;  
    {RIGHT = 1;}
    
    //在构造器里赋值了
    final int UP;
     
    //构造器
    public FinalA(){
        UP = 2;
    }
 	
    public void show(){
       //在方法体内赋值局部变量
       final int NUM = 2;
    }
    
    //在形参处设置final，只能调用，不能修改
    public void eat(final int WEIGHT){
        //WEIGHT=2;
        System.out.println(WEIGHT);
    }
}
```







## 关键字-abstract-抽象类



- `abstact`可以用来修饰的结构：类、方法

- `abstract`修饰类：抽象类

  - 此类不能实例化
  - 抽象类中有构造器。（即使父类不可以实例化，但是子类实例化需要调用父类的构造器）
  - 开发中会提供抽象类的子类，让子类实例化以完成相关操作

- `abstract`修饰方法：抽象方法

  - 抽象方法只有方法的声明，没有方法体

  - 抽象方法所在的类，必须是抽象类。反之，抽象类可以没有抽象方法

  - 父类存在抽象方法，子类必须重写父类的抽象方法

    父类存在抽象方法，子类为抽象类，则可以不重写

    - （反正有抽象方法必不能被调用）

- `abstract`使用注意

  - 不能用来修饰私有方法、静态方法、`final`修饰的方法 
    - 都不能重写方法
  - 不能用来修饰`final`类
    - 不提供子类



```java
public class AbstractClass{
    public static void main(String[] args){
        //不可实例化
        //Person p1 = new Person();
    }
}

//抽象类
abstract class Person{
    String name;
    
    //虽然不可以实例化，但是子类实例化也会调用父类的构造器
    public Person(String name){
        System.out.println(name);
    }
    
    //抽象方法
    public abstract void eat();
}

class Student extends Person{
    public Student(){}
    //重写抽象方法
    public void eat(){
        System.out.println("吃吃吃吃");
    }
}

//子类也为抽象类
abstract class Worker extends Person{
    public Worker(){}
    public void drink(){
        System.out.println("喝喝喝喝");
    }
}
```





### 抽象类的匿名子类

> 省事，不用再造一个子类

```java
public class PersonTest{
    public static void main(String[] args){
        //非匿名类的匿名对象
        method(new Student());
        
        //非匿名类的非匿名对象
        Student s = new Student();
        

        //这是匿名子类的非匿名对象
        //为什么叫匿名子类？因为只有子类才能重写方法
        Person p = new Person(){
            @Override
            public void show(){
                System.out.println("吃吃吃");
            }
        };
        
        //这是匿名子类的匿名对象
        method(new Person(){
            @Override
            public void show(){
                System.out.println("吃吃吃");
            }
        });
        
    }

    public static void method(Person person){}
}

abstract class Person{
    public Person(){}

    public abstract void show();
}

class Student extends Person{
    public Student(){}

    @Override
    public void show(){}
}

```







## 关节字-interface-接口

> 接口使用	`interface`来定义
>
> Java中，接口和类是并列的结构。接口通过让类去实现（`implements`）的方式来使用。
>
> - 如果实现类覆盖了接口中所有的抽象方法，则此实现类就可以实例化
> - 如果实现类没有覆盖了接口中所有的抽象方法，则此类仍为一个抽象类



> 接口的具体使用，体现多态性

> 接口，实际可以看成一组规范，制定好后大家必须遵守。

**1、如何定义接口：定义接口中的成员**

- JDK7及以前，<font color='red'>接口内</font>只能定义全局常量和抽象方法

	- 全局常量：`public static final`，但是书写时可以省略
	- 抽象方法：`public abstarct`

- JDK8，除了定义全局常量和抽象方法外，还可以定义静态方法、默认方法

	

2、**<font color='red'>接口中不能定义构造器！</font>意味着接口不可以实例化**



3、Java类可以实现多个接口	-------->	打破了单继承的局限

​		格式：`class AA extends BB implements CC,DD,EE{ }`



4、接口与接口之间可以继承，而且可以多继承

```java
public class InterfaceTest {
    public static void main(String[] args) {

    }
}


interface Attackable{}

interface Flyable{

    //全局常量
    public static final int MAX_SPEED = 7900;
    //可以省略 public static final，效果一样
    int MIN_SPEED = 1;

    //抽象方法
    public abstract void fly();
    //可以省略 public abstract，效果一样
    void stop();

}

class Plane implements Flyable{

    @Override
    public void fly() {
        System.out.println("飞机起飞");
    }

    @Override
    public void stop() {
        System.out.println("飞机降落");
    }
}

//Java类可以实现多个接口
//有继承父类时，格式如下
class Bullet extends Object implements Flyable,Attackable{

    @Override
    public void fly() {
    }

    @Override
    public void stop() {
    }
}

interface AA{}
interface BB{}
//多继承
interface CC extends AA,BB{}
```















# 四、`Object`类的使用

`java.lang.Object`类

1. 所有的Java类，都直接或间接继承于`java.lang.Object`类
2. 如果在类的声明中，没有用`extends`关键字指明其父类的话，则此类继承于`java.lang.Object`类
3. 意味着所有Java类都有`java.lang.Object`类的功能



`Object`类只声明了一个空参构造器

`Object`类无属性

`Object`类方法：

## `clone()`

- `Student s2 = (Student)s1.clone()`
- 克隆完后，`s1`和`s2`没有什么关系



## `equals()`

- 对于基本类型是比较值，对于引用类型是比较内存地址
- 一般都会重写，来进行使用。IDEA中`alt+insert`能自动写入`equals()`
- 详见EX-4



## `toString()`

- `Object`类中`toString()`的定义：

  ```java
  public String toString(){
      return getClass().getname()+"@"+Integer.toHexString(hashCode());
  }
  
  //其返回值是`String`类型，返回类名和它的引用地址
  Customer cust1 = new Customer("Tom",21);
  System.out.println(cust1.toString());//com.atguigu.java1.Customer@15db9742
  ```

- `String `、`Date`、`File`、包装类都<font color='red'>重写</font>了`Object`类的`toString()`方法

  - 使得在调用`toString()`时，返回相应的内容信息

  ```java
  Date now = new Date();
  System.out.println("now="+now);
  //相当于
  System.out.println("now="+now.toString());
  ```

- 基本类型数据转为`String`类型，调用了对应<font color='red'>包装类</font>的`toString()`方法

  ```java
  int a = 10;
  System.out.println("a="+a);
  ```
  
- 可以根据需要在自定义的类中重写`toString()`方法，返回内容

  IDEA使用`alt+insert`快速写入

  ```java
  @Override
  public String toString(){
      return "Customer[name = "+name+",age = "+age+"]";
  }
  ```

  



  

# 五、包装类的使用

> `Java`提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征，以可以调用`toString`等方法
>
> 需要掌握：基本类型、包装类、`String`之间的相互转换

| 基本数据类型 |               包装类               |
| :----------: | :--------------------------------: |
|     byte     |                Byte                |
|    short     |               Short                |
|     int      |  <font color='red'>Integer</font>  |
|     long     |                Long                |
|    float     |               Float                |
|    double    |               Double               |
|     char     | <font color='red'>Character</font> |
|   boolean    |              Boolean               |



## 基本数据类型 <----->包装类

```java
   //基本数据类型 -----> 包装类：调用包装类的构造器
    @Test
    public void test1(){
        int num1 = 10;

        Integer in1 = new Integer(num1);
        System.out.println(in1.toString());//10

        Integer in2 = new Integer("123");
        System.out.println(in2.toString());//123

        //报异常
		//Integer in3 = new Integer("123abc");
		//System.out.println(in3.toString());

        Boolean b1 = new Boolean("tRuE");
        System.out.println(b1.toString());//true

        Boolean b2 = new Boolean("true123");
        System.out.println(b2.toString());//false
    }
    
    //包装类 -----> 基本数据类型：调用包装类的xxxValue
    @Test
    public void test2(){
        Integer in1 = new Integer(12);
        
        int i1 = in1.intValue();
        
        long l1 = in1.longValue();
        System.out.println(l1);
    }
```



### 自动装箱&自动拆箱

> `JDK5.0`后的新特性
>
> 自动装箱：基本数据类型直接转为包装类，不用`new`
>
> 自动拆箱：包装类直接转为基本数据类型，不用`xxxValue`

```java
//自动装箱：基本数据类型--->包装类
int num1 = 10;
Integer num2 = num1;//自动装箱

boolean b1 = true;
Boolean b2 = b1;//自动装箱

//自动拆箱：包装类 ---> 基本数据类型
int num3 = num2;//自动拆箱
```



## 基本数据类型、包装类 <-----> String类型


```java    
    //基本数据类型、包装类 ---> String类型
    @Test
    public void test3(){
        int num1 = 10;
        
        //方式一：连接运算
        String s1 = num1 + "";
        
        //方式二：调用String重载的valueOf
        float f1 = 12.3f;
        String s2 = String.valueOf(f1);
        
        Double d1 = new Double(22.4);
        String s3 = String.valueOf(d1);
    }
    
    //String类型 ---> 基本数据类型、包装类:调用	包装类.parseXxx()
    @Test
    public void test4(){
        String s1 = "123";
        //错误情况
        //int i1 = (int)s1;
        //Integer in1 = (Interger)s1
        int i1 = Integer.parseInt(s1);
    }
}
```



## 面试题

```java
	@Test
    public void test1() {
        Integer i = new Integer(1);
        Integer j = new Integer(2);
        System.out.println(i == j);//false
        
         /*
        Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]
        保存从-128~127范围内的整数。如果使用自动装箱的方式，给Integer赋值的范围在
        -128-127范围内时，可以直接使用数组中的元素，不用再去new，提高装箱的效率
        */
        Integer m = 1;
        Integer n = 2;
        System.out.println(m == n);//true

        Integer x = 128;//相当于new了一个对象
        Integer y = 128;//相当于new了一个对象
        System.out.println(x == y);//false
    }
```






# 面向对象特征之一：封装

> 一、为什么要封装？
>
> - 我要用洗衣机，只要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗
>
> - 我们的程序追求“高内聚，低耦合”
> 	- 高内聚：类的内部操作细节自己完成，不允许外部干涉
> 	- 低耦合：仅对外暴露少量的方法用于是用
> - 隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性
> - 把该隐藏的隐藏，该暴露的暴露，就是封装性的设计思想

> 封装性的举例：
>
> 将类的属性X私有化（private），同时提供公共的（public）方法来获取和设置此属性的值



## 1、描述封装性

Java提供4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小



## 2、四种权限修饰符

Java规定的4种权限修饰符（从小到大排列）

- private、缺省(默认)、protected、public

| 修饰符     | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| ---------- | ------ | -------- | ------------ | ---------- |
| private    | Yes    |          |              |            |
| 缺省(默认) | Yes    | Yes      |              |            |
| protected  | Yes    | Yes      | Yes          |            |
| public     | Yes    | Yes      | Yes          | Yes        |

> 不同包的子类指的是，不同包下，以该类为父类的子类

- 4种权限可以用来修饰类的内部结构：属性、方法、构造器、内部类

- 只可以用`public `和 `缺省（默认）`来修饰类
  - public类，可以在任意地方被访问
  - 缺省的类，只可以被同一个包内部的类访问

- 四种权限修饰符都可以用来修饰方法，效果见上表
- ==即便引用该包，也不能在其他包下使用该包下缺省修饰的类==

```java
public class OrderTest{
    private int number;
    
    private void methodPrivate(){
        System.out.println("private");
    }
    void methodDefault(){
        System.out.println("default");
    }
    public void methodPublic(){
        System.out.println("public");
    }
}
class OrderTestEx{
    int age;
    public int money;
}
```







# 面向对象特征之二：继承性

>继承性的好处：
>
>- 减少了代码的冗余，提高了代码的复用性
>- 便于功能的扩展
>- 为之后多态性的使用，提供了前提



>继承格式：`class A extends B{}`
>
>- A：子类、派生类、subclass
>
>- B：父类、超类、基类、superclass



> 子类A获取父类B所声明的<font color="red">所有</font>属性、方法
>
> - 子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的拓展
> - 子类不能直接访问父类中私有的成员变量和方法
>
> - 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中的私有结构。只是因为封装性的影响，使得子类不能直接调用父类的结构。
>   - 可以在父类中public方法中调用private方法，再在子类中调用该public方法，发现private方法也执行了，证明子类仍然获取了父类中的结构。



> Java只支持单继承和多层继承，不允许多重继承
>
> - 一个子类只能有一个父类👉单继承
> - 一个父类可以派生出多个子类👉多层继承
> - 不允许一个子类同时继承多个父类👉多重继承（C++允许）
>
> 子类直接继承的父类，称为：直接父类
>
> 子类间接继承的父类，称为简介父类（子类父类的父类）



```java
//Person 是父类
public class Student extends Person {
//    String name;//父类里已经定义过
//    int age;
    String major;

    //构造器不能删
    public Student(){
    }
    public Student(String name, int age, String major){
        this.name = name;
        this.age = age;
        this.major = major;
    }
    
    //在父类里面定义过，删除
//    public void eat(){
//        System.out.println("吃饭");
//    }
    
    public void study(){
        System.out.println("学习");
    }
}
```









## 1、方法的重写

> 子类和父类中同名同参数的方法，要么都声明为`非static`的，要么都声明为`static`
>
> - `非static`的方法才可以重写
>
> - `static`方法不可以重写，不可以被覆盖，会随着类的加载而加载
>
> 	
>
> 一般在重写的方法前加上@Override



1、重写：子类继承父类后，可以对父类中同名同参数的方法，进行覆盖操作

2、应用：重写以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法

3、重写的规定

 ​			方法的声明：	权限修饰符	返回值类型	方法名（形参列表） throws  异常的类型{

 ​															方法体

 ​										}

 - 子类重写方法的<font color='red'>方法名和形参列表</font>，要和父类中被重写方法的<font color='red'>方法名和形参列表</font>相同
 - 子类重写方法的权限修饰符，不能小于父类被重写方法的权限修饰符
   - 特殊情况，子类不能重写父类中声明为`private`权限的方法
   - 一般，重写方法的权限修饰符和被重写方法的一致
 - 返回值类型
   - 父类被重写方法的返回值类型是`void`类型，子类重写方法的返回值类型只能是`void`类型
   - 父类被重写方法的返回值类型是`A`类型，子类重写方法的返回值类型可以是`A`类型或`A`类的子类
   - 父类被重写方法的返回值类型是基本类型`(如:int)`，子类重写方法的返回值类型必须是相同的基本类型`(如:int)`
- 子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型



```java
public class Student extends Person{
    String major;
    
    //构造器
    public Student(){
  
    }
    public Student(String major){
        this.major=major;
    }
    //父类Person已经存在方法 public void eat(String food)
    @Override
    public void eat(String food){
        System.out.println("我爱吃"+food);
    }
}
```



```java
//注：show(String ... strs) 与 show(String [] strs)等价
//构成重写
//但是注意直接使用show(String [] strs)，依然只能传入数组类型变量
class Base{
    public void add(int a,int... arr){
        System.out.println("base_1");
    }
}
class Sub extends Base{
    
    public void add(int a,int[] arr){
        System.out.println("sub_1");
    }
}
```







## 2、子类对象实例化的全过程



- 从结果上看

  - 子类继承父类以后，就获得了父类中声明的属性和方法
  - 创建子类的对象时，在堆空间，就会加载所有父类中声明的属性

- 从过程上看

  ​		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器...直到调用`java.lang.Object`类中空参的构造器为止。

  ​		正因为加载过所有父类的结构，所以才可以看见内存中有父类中的结构，子类对象才可以调用

  > 为什么会直接&间接的调用父类的构造器?
  >
  > ​		因为子类的构造器首行只能用`this`或`super`调用构造器
  >
  > ​		只有子类存在两个及以上构造器时，子类构造器中才可以用`this`调用其他构造器，然而这也必会存在一个构造器不能用`this`，故子类必会存在一个构造器使用`super`（或者系统默认调用）。



- ==明确：==

  虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象













# 面向对象特征之三：多态性

> 什么是多态性：
>
> ​		对象的多态性，父类的引用指向子类的对象



==多态是运行时行为，不是编译时行为==

- 只有在运行的时候，才知道调的是哪个子类的方法。编译时看不出。



 多态的使用——虚拟方法使用

 ​			` Person p2 = new Man();`

 - 在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是==子类重写父类的方法==
   - 如`p2.eat()`，编译的时候，会检查父类中有没有`eat()`这个方法，追踪该方法也会指向父类。但是实际执行，是执行子类中的`eat()`
   - 编译看左边（即`Person`类），运行看右边（即`Man`类）
 - 属性：<font color='red'> 多态性，只适用方法，不适用属性。使用属性时，编译和运行都看左边（`person`类）</font>



> 1、若子类重写了父类的方法，就意味着子类里定义的方法彻底覆盖了父类里同名的方法
>
> ​      系统将不可能把父类里的方法转移到子类，编译看左边（父类），运行看右边（子类）
>
> 2、对于实例变量则不存在这样的现象。即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量
>
> ​      编译运行都看左边（即父类）



> 多态的使用前提
>
> 1. 要有类的继承关系
> 2. 要有方法的重写，否则就没有必要`new`子类对象



```java
public class PersonTest{
    public static void main(String[] args){
        //Person 是 Man 的父类
        Person p1 = new Person();
        p1.eat();
        
        Man m1 = new Man();
        m1.age = 25;
        m1.eat();
        m1.earnMoney();
     
        //对象的多态性，父类的引用指向子类的对象
        Person p2 = new Man();
        
        //多态的使用
        //当调用子父类同名同参数的方法时，实际执行的是子类重写以后的方法————虚拟方法使用
        p2.eat();
        
        //编译过不去，父类没有该子类特有的方法
        //p2.earnMoney();
    }
}
```





## 多态性的使用

使用：方法的形参是父类，传入是子类，使用的是子类重写的方法

​		举例一，声明的是父类，赋的是子类

```java
public class AnimalTest {
    
    public static void main(String[] args) {
        
        AnimalTest a1 = new AnimalTest();
        
        //要求传入Animal，但是传入Dog，这就是多态
        //不再需要造很多重载的方法，以适应Dog，Cat类型的变量
        a1.func(new Dog());
        a1.func(new Cat());
       
    }
    public void func(Animal animal){//Animal animal = new Dog()
        animal.eat();
    }

}
class Animal{
    public void eat(){
        System.out.println("Animal eat");
    }
}
class Dog extends Animal{
    public void eat(){
        System.out.println("Dog eat");
    }
}
class Cat extends Animal{
    public void eat(){
        System.out.println("Cat eat");
    }
}
```

​		举例二，简化子类方法的重写

```java
class Order{
    public void method(Object obj){
        //可以传多种子类，省去了写多个重载的方法
        //可以只写一次子类的重写方法
        
        //重写obj.method1();
        //重写obj.method2();    
    }
}
```

### 面试题

```java
public class MoreTest{
    public static void main(String[] args){
        //1、输出什么
        Base base = new Sub();
        base.add(1,2,3);//sub_1
        //因为编译调用的是父类的方法，运行则是调用子类重写父类的该方法
        //但是注意直接使用show(String [] strs)的话，依然只能传入数组类型变量
        
        //2、输出什么
        Sub sub = (Sub)base;
        sub.add(1,2,3);//sub_2
    }
}

class Base{
    public void add(int a,int... arr){
        System.out.println("base_1");
    }
}

class Sub extends Base{
    
    public void add(int a,int[] arr){
        System.out.println("sub_1");
    }
    
    public void add(int a,int b,int c){
        System.out.println("sub_2");
    }
}
```





## 虚拟方法调用

子类中定义了与父类同名同参数的方法，<font color='red'>在多态情况下</font>，将此时父类的方法称为虚拟方法。

> 父类方法是虚的，编译时让你看一下，实际执行时子类的方法



父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法在编译期是无法确定的。

​												`Person p1 = new Student();`

​												`p1.getInfo();//调用Student类的getInfo方法`

动态绑定：

​	Java由于存在多态，所以编译时无法确定右边的类型（是子类，还是子类的子类），只能在运行时确认 

- 编译时看左边，`p1`的调用地址为`Person`类的`getInfo方法`，
- 运行时看右边，调用的是`Student`类的`getInfo`方法
- 两次的地址不同，即是动态绑定







## 向下转型



> 在多态，`Person p1 = new Man()`中，
>
> 内存中实际上是加载了子类特有的属性和方法的
>
> 但是由于变量类型声明为父类类型，导致编译时只能调用父类声明的属性和方法，子类特有的属性和方法不能调用
>
> 如今，我们想要使用子类特有的属性和方法



> 类比变量的自动类型提升和强制转型
>
> - 向上转型：多态
> - 向下转型：使用`instance of `进行判断
> 	- 使用强制类型转换符

```java 

//向下转型
//相当于在栈中新建变量m1，指向p1指向的Man()地址
Person p1 = new Man();
Man m1 = (Man)p1;
m1.earnMoney();


//情景一，编译通过，但运行失败
//Person p2 = new Man();
//Woman w1 = (Woman)p2;
//w1.goShopping();

//该情况不能向下转型，使用instanceof判断能不能向下转型


//情景二,编译通过，但运行失败
//这样是不可以的，new的是父类对象，不能转成子类
//Person p3 = new Person();
//Man m2 = (Man)p3

    
//情景三，编译通过，运行通过
//这样是可以的
Object obj = new Woman();
Person p4 = (Person)ogj
```





### `instanceof`操作符

> `x instanceof A`：检验x是否为类 A 的实例，返回值为`boolean`类型
>
> - 要求 x 所属的类与类 A 必须是子类和父类的关系，否则编译错误
>
> - <font color='red'>如果 x 属于类 A 的子类 B ，返回的`boolean`值也为 true </font>



为了避免在向下转型时出现`ClassCastException`的异常，我们在向下转型前，先进行`instanceof`的判断

- 返回`true`进行向下转型

- 返回`false`不进行向下转型

```java
if(p2 instanceof Woman){
    Woman w1 = (Woman)p1;
	w1.goShopping();
    System.out.println("Woman");
}

if(p2 instanceof Man){
	Man m1 = (Man)p1;
	m1.earnMoney();
    System.out.println("Man");
}
```




















# EX-1、JVM内存结构与对象解析

![](E:%5CLearning%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5Cimage-20201108154358774.png)

- 虚拟机栈，即平时所说的栈结构。<font color="red">我们平时将局部变量存储在栈结构</font>
- 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。对象的属性（非static）也在堆空间中
- 方法区：类的加载信息、常量池、静态域





# EX-2、`JavaBean`

> ​		用户可以使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的`JSP页面`、`Servlet`、其他`JavaBean`、applet程序或者应用来使用这些对象。
>
> ​		用户可以认为`JavaBean`提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

- `JavaBean`是一种Java语言写成的可重用组件
- 所谓``JavaBean`是指符合如下标准的Java类
	- 类是公共的
	- 有一个无参的公共的构造器
	- 有属性，且有对应的get、set方法















# EX-3、 MVC设计模式

> MVC是常用的设计模式之一，将整个程序分为三个层次，视图模型层、控制器层、数据模型层。
>
> 这种将程序输入输出、数据处理、数据展示分离开的设计模式，使程序结构灵活清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性

- 模型层  model  处理数据

- 视图层  view  显示数据
- 控制层  controller 处理业务逻辑

![MVC](E:%5CLearning%5C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets%5CMVC.png)







# EX-4、面试题：`equals`与`==`的区分

- `==`既可以比较基本类型也可以比较引用类型。对于基本类型是比较值，对于引用类型是比较内存地址

- `equals()`是属于`java.lang.Object`类里面的方法，==如果该方法没有被重写过==，则默认也是`==`。

  我们看到的`String`等类的`equals`方法是被重写过的，而且`String`类在日常开发中用的比较多，所以可能会有`equals()`是比较值的错误观点

- `==`符号使用时，必须保证左右两边变量类型一致

- 通常情况下，重写`equals()`方法，会比较类中的相应属性是否相等



**详细解释**

（1）`==`，是一个运算符

- 可以使用在基本数据类型变量和引用类型数据变量中
  - 如果比较的是==基本==数据类型变量，比较两个变量保存的数据是否相等（不一定类型相同）
  - 如果比较的是==引用==数据类型变量，比较两个对象的地址值是否相同
- `==`符号使用时，必须保证左右两边变量类型一致
  - 如：`System.out.println( "hellp" == new java.util.Date())`
  - 左边`String`类型，右边`Date`类型，编译会报错。类似`Boolean`和其他基本类型运算。 

```java
public class EqualTest{
    public static void main(String[] args){
        //基本数据类型
        int i = 10;
        int j = 10;
        double d = 10.0;
        System.out.println(i==j);//true
        System.out.println(i==d);//true,i会自动类型提升为double

        boolean b = true;
        //System.out.println(1 == b);//boolean 不能用于运算符

        char c =10;
        System.out.println(i==c);//true

        char c1='A';
        char c2 = 65;
        int m = 65;
        System.out.println(m==c1);//true
        System.out.println(c2==c1);//true

        //引用数据类型
        Customer cust1 = new Customer("Tom",21);
        Customer cust2 = new Customer("Tom",21);
        System.out.println(cust1==cust2);//false
        
        //String
        String cust1 = "Tom";
        String cust2 = "Tome";
        System.out.println(cust1==cust2);//false
        
        String cust1 = "Tom";
        String cust2 = "Tom";
        System.out.println(cust1==cust2);//true
        
        String cust1 = "Tom";
        String cust2 = new String("Tom");
        System.out.println(cust1==cust2);//false
    }
} 
```



（2）`equals()`，是一个方法，非运算符

- 只适用于引用数据类型

- `Object`类中`equals()`的定义：

  ```java
  public boolean equals(Object obj){
      return (this == obj);
  }
  ```

  说明：`Object`类中定义的`equals()`和`==`作用相同，比较两个对象的地址值是否相同

- `String `、`Date`、`File`、包装类都<font color='red'>重写</font>了`Object`类的`equals()`方法

  - 重写了以后，比较的不再是两个对象的<font color='red'>引用地址</font>是否相同，而是比较两个对象的<font color='red'>内容</font>是否相同

- 通常，我们<font color='red'>自定义的类</font>如果使用`equals()`的话，也通常是<font color='red'>比较两个对象的内容是否相同</font>

  那么我们就需要对`equals()`方法<font color='red'>重写</font>

  IDEA中可以使用`alt+insert`快速插入





# EX-5、单元测试

`Java`中的`JUnit`单元测试

- 新建一个名为 test 的目录
  
- 右键该目录选择 Make Directory as -> Test Source Root
  
- 创建`Java`类，进行单元测试。

  此时的`Java`类要求：

  ​	1、此类是`public`			2、此类提供公共的无参构造器

- 此类中声明单元测试方法

  方法权限是`public`，没有返回值，没有形参

- 方法前需要加上声明注解：`@Test`，并在单元测试类导入`import org.junit.Test`

- 声明好单元测试方法后，就可以在方法体内测试相关代码

- 写完代码以后，左键双击单元测试方法名，选择`RUn as JUnit Test`

```java
import org.junit.Test
public class JUnitClass{
    @Test
    public void testEquals(){
        String s1 = "MM";
        String s2 = "MM";
        System.out.println(s1.equals(s2));
    } 
    //可以双击方法名，选择运行哪个测试方法
    //一小波用一个单元测试方法，另一小波再用一个单元测试方法
    @Test
    public void testToString(){
        String s1 = "MM";
        System.out.println(s1.toString());
    } 
}
```



# EX-6 、属性赋值的顺序

1、默认初始化

2、显示初始化	/	在代码块中赋值	<font color = 'red'>（看谁先写）</font>

3、构造器中初始化

4、有了对象以后，可以通过`对象.属性`或`对象.方法`进行赋值

```java
public class PeopleTest{
    //默认初始化
    int age;
    //显式初始化
    int age = 1;
    //代码块
    {
        age = 4;
    }
}
```






# EX-7、单例设计模式

> 对某个类只能存在一个实例

- 饿汉式：
  - 好处：饿汉式线程是安全的
  - 坏处：对象加载时间长
- 懒汉式：
  - 好处：延迟对象的创建
  - 坏处：目前写法是不安全的

```java
//饿汉式实现
public class SingleTest1{

    public static void main(String[] args) {
        Bank bank1 = Bank.getInstance();
        Bank bank2 = Bank.getInstance();
        System.out.println(bank1 == bank2);
    }
}
class Bank{

    //1.私有化类的构造器
    private Bank(){   }

    //2.声明当前类的对象，要求此对象也是静态的
    private static Bank instance = new Bank();

    //3.提供public、static的方法，返回类的对象
    public static Bank getInstance(){
        return instance;
    }
}


//懒汉式实现
public class SingleTest2{

    public static void main(String[] args) {
        Order order1 = Order.getInstance();
        Order order2 = Order.getInstance();
        System.out.println(order1 == order2);
    }
}
class Order{

    //1.私有化类的构造器
    private Order(){   }

    //2.声明当前类的对象，没有初始化
    private static Order instance = null;

    //3.提供公共的静态的方法，返回类的对象
    public static Order getInstance(){
        if (instance == null){
            instance = new Order();
        }
        return instance;
    }
}
```





