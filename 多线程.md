Editor——General——Auto import

Editor——General——Code Completion

Editor——File Encoding

Build,Execution,Deployment——compiler



# 一、基本概念



### 程序、线程和进程

-  **程序**：为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。

-  **进程**：程序的一次执行过程，或是正在运行中的一个程序

-  **线程**：（进程可以进一步细化为线程，）是程序内部的一条执行路径

  - 若一个进程同一时间并行执行多个线程，就是支持 **多线程** 的

  - **线程**作为调度和执行的单位，每个线程拥有独立的**运行栈**和**程序计数器**（`pc`），线程切换花销小

  - <font color="red">一个进程中的多个线程共享相同的内存单元/内存地址空间。</font>

    他们从同一堆中分配对象，可以访问相同的变量和对象。



### 单核/多核CPU

- **单核CPU**，其实是假的多线程。CPU是通过把一个线程挂起，再执行其他线程的方式，达到一种多线程的效果。因为CPU的时间单元非常短，所以感觉不出来

- **多核CPU**，更好的发挥多线程的效率，现在服务器都是多线程的。

  

  一个Java应用程序`Java.exe`，至少有三个线程：`main()`主线程，`gc()`垃圾回收线程，异常处理线程。



### 并行/并发

- **并行**，多个CPU同时执行多个任务。
- **并发**，一个CPU（采用时间片）同时执行多个任务。



### 多线程的优点

- 提高应用程序的响应。对图形化界面更有意义，可增强用户体验
- 提高计算机系统CPU的利用率
- 改善程序结构。将既长又复杂的进程分解为多个线程，独立运行，便于理解和修改



### 何时需要多线程

- 程序需要同时执行两个或多个任务
- 程序需要实现一些需要等待的任务，如用户输入、文件读写、网络操作、搜索等
- 需要一些在后台运行的程序时





# 二、线程的创建和使用



> Java语言的`JVM`允许程序运行多个线程，通过`java.lang.Thread`类来体现



## 1、多线程的创建-方式一



**方式一：继承`Thread`类**

1. 创建一个继承于`Thread`类的子类

2. 重写`Thread`类的`run()`

   将此线程要执行的操作声明在`run()`中

3. 创建`Thread`类的子类的对象

4. 通过此对象调用`start()`



- 如果线程仅使用一次，可以通过创建匿名子类的方式



**注意事项**：

1. 不能通过调用`run()`的方式启动线程，必须调用`start()`

2. 已经`start()`的线程 ，不能再`start()`执行，会报异常

   如果要再此执行该线程，需要重新创建一个线程对象，再调用`start()`

   ```java
   //再启动一个线程，遍历100以内的偶数
   MyThread t2 = new MyThread();
   t2.start();
   ```

   

```java
public class ThreadTest {
    public static void main(String[] args) {
        //3.创建子类的对象
        MyThread t1 = new MyThread();
        
        //4.通过此对象调用run();①启动当前线程 ②调用当前线程的run()
        t1.start();
		
        //如下操作在main线程中执行
        for(int i=0;i<10;i++){
            System.out.println(Thread.currentThread().getName()+":"+i+"hello");
        }
    }
}

//1.创建一个继承于`Thread`类的子类
class MyThread extends Thread {

    //2.重写`Thread`类的`run()`
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}
```

```java
//创建匿名子类的方式
new Thread(){
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}.start();
```





## 2、`Thread`类的方法

- `void start();`，启动线程，并执行对象的run()方法

- `void run();`，线程在被调度时执行的操作

- `String getName();`，返回线程的名称

- 1. `void setName(String Name);`，设置该线程的名称

  2. Thread类提供构造器`Thread(String Name)`，通过构造器的方式进行命名

- `static Thread currentThread();`，返回当前线程。在Thread子类中就是this，

- `yield();`，释放当前线程。但是下一刻当前线程还有可能被分配到CPU

- `join();`，

  在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完，线程a才结束阻塞状态

- `sleep(long millitime)`，让当前线程睡眠指定毫秒数，1000毫秒=1秒

- `isAlive();`，判断当前线程是否存活





```java
public class ThreadTest {
    public static void main(String[] args) {

        MyThread t1 = new MyThread("线程1111");
        t1.start();

        //给线程命名
        t1.setName("线程一");
        //给主线程命名
        Thread.currentThread().setName("主线程");

        for(int i=0;i<100;i++){
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
            if (i==20){
                try {
                    //在主线程中，调用线程一的join()
                    t1.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        //判断线程一是否还存活
        System.out.println(t1.isAlive());
    }
}


class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+":"+i);
            }

            try {
                sleep(10);//单位：毫秒//可以把时间设长一点更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (i % 20 ==0) {
                //释放当前线程
                yield();
                //但下一刻可能还会被分配到当前线程
            }
        }
    }

    public MyThread(String Name){
        super(Name);
    }
}
```





## 3、线程的调度



**调度策略：**

- 时间片：
- 抢占式：<font color='red'>高优先级</font>的线程抢占CPU

**Java的调度方法：**

- 同优先级线程组成先进先出队列，使用时间片策略
- 对于高优先级，使用优先调度的抢占式策略



### 线程的优先级



**线程的优先级等级：**

- `MAX_PRIORITY`：10
- `MIN_PRIORITY`：1
- `NORM_PRIORITY`：5

**涉及的方法：**

- `getPriority`：返回线程优先级
- `setPriority(int newPriority)`：改变线程的优先级

**注意：**

- 线程创建时，继承父线程的优先级
- 低优先级只是获得调度的概率低，并非一定是在高优先级之后才被调用



```java
Thread.currentThread().getPriority();
Thread.currentThread().setPriority(1);
t1.setPriority(MIN_PRIORITY);
t1.setPriority(MAX_PRIORITY);
```





## 4、多线程的创建-方式二



**方式一：实现`Runnable`接口**

